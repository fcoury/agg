<<<START_FILE:/Users/fcoury/code/paperiq/client/src/contexts/user_context.rs>>
use crate::http::{get, Error};
use paperiq_types::UserWithSettings;
use web_sys::console;
use yew::prelude::*;
use yew_hooks::prelude::*;

#[derive(PartialEq, Clone, Debug)]
pub struct UserContextState {
    pub user: Option<UserWithSettings>,
    pub is_loading: bool,
}

#[derive(PartialEq, Clone, Debug)]
pub struct UserContext {
    pub state: UseStateHandle<UserContextState>,
    pub update_user: Callback<Option<UserWithSettings>>,
}

#[derive(Properties, PartialEq)]
pub struct UserProviderProps {
    pub children: Children,
}

#[function_component(UserProvider)]
pub fn user_provider(props: &UserProviderProps) -> Html {
    console::log_1(&"UserProvider".into());

    let user_context_state = use_state(|| UserContextState {
        user: None,
        is_loading: true,
    });

    let update_user = {
        let user_context_state = user_context_state.clone();
        Callback::from(move |new_user: Option<UserWithSettings>| {
            user_context_state.set(UserContextState {
                user: new_user,
                is_loading: false,
            });
        })
    };

    let user_state: UseAsyncHandle<UserWithSettings, Error> = use_async(async move {
        let resp = get("/api/user").await?;
        let user: UserWithSettings = resp.json().await?;
        Ok(user)
    });

    {
        let user_state = user_state.clone();
        use_effect_with((), move |_| {
            user_state.run();
            || {}
        });
    }

    // {
    //     let user_context_state = user_context_state.clone();
    //     use_effect_with(user_state, move |user_state| {
    //         console::log_1(&format!("here user_state: {:?}", user_state.data).into());
    //         if let Some(user) = &user_state.data {
    //             user_context_state.set(UserContextState {
    //                 user: Some(user.clone()),
    //                 is_loading: false,
    //             });
    //         }
    //         || {}
    //     });
    // }

    {
        let update_user = update_user.clone();
        use_effect_with(user_state, move |user_state| {
            if let Some(user) = &user_state.data {
                update_user.emit(Some(user.clone()));
            }
            || {}
        });
    }

    let user_context = UserContext {
        state: user_context_state,
        update_user,
    };

    html! {
        <ContextProvider<UserContext> context={user_context}>
            { for props.children.iter() }
        </ContextProvider<UserContext>>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/contexts/user_context.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/contexts/mod.rs>>
mod user_context;

pub use user_context::{UserContext, UserProvider};

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/contexts/mod.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/models/mod.rs>>
mod form;
mod scan;

pub use form::{Form, FormData};
pub use scan::ScanRequest;

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/models/mod.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/models/scan.rs>>
use csv::ReaderBuilder;
use paperiq_types::ScanField;
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ScanRequest {
    pub id: i32,
    pub status: String,
    pub percentage: i32,
    pub images: Vec<String>,
    pub response: Option<Value>,
    pub data: Option<Value>,
    pub created_at: chrono::NaiveDateTime,
    pub modified_at: chrono::NaiveDateTime,
}

impl ScanRequest {
    pub fn fields(&self) -> Vec<ScanField> {
        let Some(data) = self.data.as_ref() else {
            return vec![];
        };

        let Some(data) = data.as_str() else {
            return vec![];
        };

        let mut rdr = ReaderBuilder::new()
            .has_headers(false)
            .from_reader(data.as_bytes());
        rdr.records()
            .map(|r| {
                let r = r.unwrap();

                ScanField {
                    name: r[0].to_string(),
                    value: r[1].to_string(),
                    accuracy: r[2].parse().unwrap(),
                    x: r[3].parse().unwrap(),
                    y: r[4].parse().unwrap(),
                    width: r[5].parse().unwrap(),
                    height: r[6].parse().unwrap(),
                }
            })
            .collect()
    }

    pub fn in_progress(&self) -> bool {
        self.status == "processing"
    }

    pub fn is_finished(&self) -> bool {
        self.status == "completed" || self.status == "error"
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/models/scan.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/models/form.rs>>
use serde::Deserialize;
use serde_json::Value;

#[derive(Deserialize, Clone, Debug)]
pub struct FormData {
    pub id: i32,
    pub data: Option<Value>,
}

#[derive(Deserialize, Clone, Debug)]
pub struct Form {
    pub id: i32,
    pub status: String,
    pub percentage: i32,
    pub error: Option<String>,
    #[serde(rename = "type")]
    pub typ: String,
    pub images: Option<Vec<String>>,
    pub file_names: Vec<String>,
    pub response: Option<Value>,
    pub data: Option<Value>,
    pub created_at: chrono::NaiveDateTime,
    pub modified_at: chrono::NaiveDateTime,
}

impl Form {
    pub fn is_form(&self) -> bool {
        self.typ == "form"
    }

    pub fn is_scan(&self) -> bool {
        self.typ == "scan"
    }

    pub fn name(&self) -> Option<String> {
        if self.typ == "form" {
            let data = self.data.as_ref()?;
            let data = data.as_object()?;
            let name = data.get("name")?;
            let name = name.as_str()?;
            Some(name.to_string())
        } else {
            None
        }
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/models/form.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/navbar.rs>>
use yew::prelude::*;

use crate::{
    components::{Loader, UserAvatar},
    contexts::UserContext,
};

#[function_component(Navbar)]
pub fn navbar() -> Html {
    html! {
        <nav class="fixed z-30 w-full bg-white border-b border-gray-200 dark:bg-gray-800 dark:border-gray-700">
            <div class="px-3 py-3 lg:px-5 lg:pl-3">
                <div class="flex items-center justify-between">
                    <div class="flex items-center justify-start">
                        <ToggleSidebar />
                        <a href="/" class="flex ml-2 md:mr-24">
                            <img src="/img/logo.png" class="h-8 mr-3" alt="PaperIQ Logo" />
                            <span class="self-center text-xl font-semibold sm:text-2xl whitespace-nowrap dark:text-white">{"PaperIQ"}</span>
                        </a>
                        <SearchBar />
                    </div>
                    <div class="flex items-center">
                        <button
                            id="toggleSidebarMobileSearch"
                            type="button"
                            class="p-2 text-gray-500 rounded-lg lg:hidden hover:text-gray-900 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
                        >
                            <span class="sr-only">{"Search"}</span>
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"></path>
                            </svg>
                        </button>
                        <NotificationButton />
                        <AppsButton />
                        <ThemeToggle />
                        <ProfileMenu />
                    </div>
                </div>
            </div>
        </nav>
    }
}

#[function_component(ToggleSidebar)]
pub fn toggle_sidebar() -> Html {
    html! {
        <button
          id="toggleSidebarMobile"
          aria-expanded="true"
          aria-controls="sidebar"
          class="p-2 text-gray-600 rounded cursor-pointer lg:hidden hover:text-gray-900 hover:bg-gray-100 focus:bg-gray-100 dark:focus:bg-gray-700 focus:ring-2 focus:ring-gray-100 dark:focus:ring-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
        >
          <svg
            id="toggleSidebarMobileHamburger"
            class="w-6 h-6"
            fill="currentColor"
            viewBox="0 0 20 20"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fill-rule="evenodd"
              d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h6a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z"
              clip-rule="evenodd"
            ></path>
          </svg>
          <svg
            id="toggleSidebarMobileClose"
            class="hidden w-6 h-6"
            fill="currentColor"
            viewBox="0 0 20 20"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fill-rule="evenodd"
              d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
              clip-rule="evenodd"
            ></path>
          </svg>
        </button>
    }
}

#[function_component(SearchBar)]
pub fn search_bar() -> Html {
    html! {
        <form action="#" method="GET" class="hidden lg:block lg:pl-3.5">
            <label for="topbar-search" class="sr-only">{"Search"}</label>
            <div class="relative mt-1 lg:w-96">
                <div class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                    <svg class="w-5 h-5 text-gray-500 dark:text-gray-400" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"></path>
                    </svg>
                </div>
                <input
                    type="text"
                    name="email"
                    id="topbar-search"
                    class="bg-gray-50 border border-gray-300 text-gray-900 sm:text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full pl-10 p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-primary-500 dark:focus:border-primary-500"
                    placeholder="Search"
                />
            </div>
        </form>
    }
}

#[function_component(NotificationButton)]
pub fn notification_button() -> Html {
    html! {
        <button
            type="button"
            data-dropdown-toggle="notification-dropdown"
            class="p-2 text-gray-500 rounded-lg hover:text-gray-900 hover:bg-gray-100 dark:text-gray-400 dark:hover:text-white dark:hover:bg-gray-700"
        >
            <span class="sr-only">{"View notifications"}</span>
            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 2a6 6 0 00-6 6v3.586l-.707.707A1 1 0 004 14h12a1 1 0 00.707-1.707L16 11.586V8a6 6 0 00-6-6zM10 18a3 3 0 01-3-3h6a3 3 0 01-3 3z"></path>
            </svg>
        </button>
    }
}

#[function_component(AppsButton)]
pub fn apps_button() -> Html {
    html! {
        <button
            type="button"
            data-dropdown-toggle="apps-dropdown"
            class="hidden p-2 text-gray-500 rounded-lg sm:flex hover:text-gray-900 hover:bg-gray-100 dark:text-gray-400 dark:hover:text-white dark:hover:bg-gray-700"
        >
            <span class="sr-only">{"View notifications"}</span>
            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM11 13a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path>
            </svg>
        </button>
    }
}

#[function_component(ThemeToggle)]
pub fn theme_toggle() -> Html {
    html! {
        <button
            id="theme-toggle"
            data-tooltip-target="tooltip-toggle"
            type="button"
            class="text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-700 rounded-lg text-sm p-2.5"
        >
            <svg id="theme-toggle-dark-icon" class="hidden w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
            </svg>
            <svg id="theme-toggle-light-icon" class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"></path>
            </svg>
        </button>
    }
}

#[function_component(ProfileMenu)]
pub fn profile_menu() -> Html {
    let user_ctx = use_context::<UserContext>().expect("No user context found");
    let user_state = &*user_ctx.state;

    html! {
        <div class="flex items-center ml-3">
            <div>
                <button
                    type="button"
                    class="flex text-sm bg-gray-800 rounded-full focus:ring-4 focus:ring-gray-300 dark:focus:ring-gray-600"
                    id="user-menu-button-2"
                    aria-expanded="false"
                    data-dropdown-toggle="dropdown-2"
                >
                    <span class="sr-only">{"Open user menu"}</span>
                    <UserAvatar />
              </button>
            </div>

            <div
                id="dropdown-2"
                style="position: absolute; inset: 0px auto auto 0px; margin: 0px; transform: translate3d(3309px, 61px, 0px);"
                class="z-50 my-4 text-base list-none bg-white divide-y divide-gray-100 rounded shadow dark:bg-gray-700 dark:divide-gray-600 hidden"
                data-popper-placement="bottom"
            >
              <div class="px-4 py-3" role="none">
                { if user_state.is_loading {
                    html! { <Loader /> }
                } else if let Some(user) = &user_state.user {
                    html! {
                        <>
                            <p class="text-sm font-medium text-gray-900 truncate dark:text-gray-300" role="none">
                                {&user.email}
                            </p>
                        </>
                    }
                } else {
                    html! { "No user found" }
                }}
              </div>
              <ul class="py-1" role="none">
                <li>
                  <a href="#" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-600 dark:hover:text-white" role="menuitem">{"Settings"}</a>
                </li>
                <li>
                  <a href="/logout" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-600 dark:hover:text-white" role="menuitem">{"Sign out"}</a>
                </li>
              </ul>
            </div>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/navbar.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/avatar.rs>>
use md5;
use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct AvatarProps {
    pub email: String,
    #[prop_or(80)]
    pub size: u32,
    #[prop_or_default]
    pub default: Option<String>,
    #[prop_or_default]
    pub rating: Option<String>,
}

#[function_component(Avatar)]
pub fn avatar(props: &AvatarProps) -> Html {
    let AvatarProps {
        email,
        size,
        default,
        rating,
    } = props;

    let email_hash = md5::compute(email.trim().to_lowercase().as_bytes());
    let email_hash_hex = format!("{:x}", email_hash);

    let mut url = format!(
        "https://www.gravatar.com/avatar/{}?s={}",
        email_hash_hex, size
    );

    if let Some(default_image) = default {
        url.push_str(&format!("&d={}", default_image));
    }

    if let Some(content_rating) = rating {
        url.push_str(&format!("&r={}", content_rating));
    }

    html! {
        <img class="w-8 h-8 rounded-full" src={url} alt={format!("Avatar for {}", email)} />
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/avatar.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/scans_table.rs>>
use std::time::Duration;

use chrono::NaiveDateTime;
use serde_json::Value;
use yew::prelude::*;
use yew_router::hooks::use_navigator;

use crate::{app::Route, components::{DataTable, FinalStateChecker, RowTransformer, RowType}, utils::get_status_class};

#[derive(Properties, Clone, PartialEq)]
pub struct ScansTableProps {
    pub kind: Option<String>,
}

#[function_component(ScansTable)]
pub fn scans_table(props: &ScansTableProps) -> Html {
    let navigator = use_navigator().unwrap();

    let headers = vec![
        "ID".to_string(),
        "Type".to_string(),
        "Last updated".to_string(),
        "Progress".to_string(),
        "Status".to_string(),
        "".to_string(),
    ];

    let row_transformer = RowTransformer::new(
        |row: serde_json::Value| -> anyhow::Result<Vec<RowType>> {
            let id = row["id"]
                .as_i64()
                .ok_or_else(|| anyhow::anyhow!("Invalid id"))?;
            let typ = match row["type"].as_str() {
                Some("scan") => "Scan",
                Some("form") => "Template",
                _ => "Unknown",
            };
            let images = row["images"]
                .as_array()
                .ok_or_else(|| anyhow::anyhow!("Invalid images"))?;
            let percentage = row["percentage"]
                .as_i64()
                .ok_or_else(|| anyhow::anyhow!("Invalid percentage"))?;
            let status = row["status"]
                .as_str()
                .ok_or_else(|| anyhow::anyhow!("Invalid status"))?;
            let modified_at: NaiveDateTime = row["modified_at"]
                .as_str()
                .ok_or_else(|| anyhow::anyhow!("Invalid date"))?
                .parse()?;

            Ok(vec![
                id.to_string().into(),
                typ.to_string().into(),
                modified_at.into(),
                html! {
                    <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                        <div 
                            class="bg-blue-600 h-2.5 rounded-full" 
                            style={format!("width: {}%", percentage)}>
                        </div>
                    </div>
                }.into(),
                html! {
                    <span
                        class={format!("px-2 py-1 text-xs font-medium rounded-full {}", get_status_class(status))}
                    >
                        { status }
                    </span>
                }.into(),
                html! {
                    <img
                        src={format!("data:image/jpg;base64,{}", images[0].as_str().unwrap())}
                        class="w-auto h-16 rounded-sm object-cover"
                        alt="Preview"
                    />
                }
                .into(),
            ])
        },
    );

    let mut endpoint = "/api/scans".to_string();
    if let Some(kind) = &props.kind {
        endpoint.push_str(&format!("?type={}", kind));
    }
    
    let onrowclick = Callback::from(move |row: serde_json::Value| {
        if row["type"].as_str() == Some("scan") {
            navigator.push(&Route::Scan { id: row["id"].as_i64().unwrap() as i32 });
        } else if row["type"].as_str() == Some("form") {
            navigator.push(&Route::Form { id: row["id"].as_i64().unwrap() as i32 });
        }
    });

    let is_final_state = FinalStateChecker::new(|row: &Value| {
        matches!(row["status"].as_str(), Some("completed") | Some("error"))
    });

    html! {
        <DataTable
            endpoint={endpoint}
            headers={headers}
            row_transformer={row_transformer}
            onrowclick={Some(onrowclick)}
            refresh_interval={Duration::from_secs(10)} // Refresh every 10 seconds
            is_final_state={Some(is_final_state)}
        />
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/scans_table.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/icons.rs>>
use yew::prelude::*;

#[derive(Clone, PartialEq, Debug)]
pub enum Icons {
    PieChart,
    FileLines,
    InboxFull,
    QuestionCircle,
    FileCsv,
}

impl From<Icons> for Html {
    fn from(icon: Icons) -> Self {
        icon.to_svg(24)
    }
}

impl Icons {
    pub fn to_svg(&self, size: usize) -> Html {
        let classes = classes!(format!(
            "w-[{}px] h-[{}px] text-gray-800 dark:text-white",
            size, size
        ));
        let str_size = format!("{}", size);

        match self {
            Icons::PieChart => html! {
                <svg class={classes} aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width={str_size.clone()} height={str_size.clone()} fill="currentColor" viewBox="0 0 24 24">
                  <path d="M13.5 2c-.178 0-.356.013-.492.022l-.074.005a1 1 0 0 0-.934.998V11a1 1 0 0 0 1 1h7.975a1 1 0 0 0 .998-.934l.005-.074A7.04 7.04 0 0 0 22 10.5 8.5 8.5 0 0 0 13.5 2Z"/>
                  <path d="M11 6.025a1 1 0 0 0-1.065-.998 8.5 8.5 0 1 0 9.038 9.039A1 1 0 0 0 17.975 13H11V6.025Z"/>
                </svg>
            },
            Icons::FileLines => html! {
                <svg class={classes} aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width={str_size.clone()} height={str_size.clone()} fill="currentColor" viewBox="0 0 24 24">
                  <path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm2-2a1 1 0 1 0 0 2h3a1 1 0 1 0 0-2h-3Zm0 3a1 1 0 1 0 0 2h3a1 1 0 1 0 0-2h-3Zm-6 4a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1v-6Zm8 1v1h-2v-1h2Zm0 3h-2v1h2v-1Zm-4-3v1H9v-1h2Zm0 3H9v1h2v-1Z" clip-rule="evenodd"/>
                </svg>
            },
            Icons::InboxFull => html! {
                <svg class={classes} aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width={str_size.clone()} height={str_size.clone()} fill="currentColor" viewBox="0 0 24 24">
                  <path fill-rule="evenodd" d="M5.024 3.783A1 1 0 0 1 6 3h12a1 1 0 0 1 .976.783L20.802 12h-4.244a1.99 1.99 0 0 0-1.824 1.205 2.978 2.978 0 0 1-5.468 0A1.991 1.991 0 0 0 7.442 12H3.198l1.826-8.217ZM3 14v5a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-5h-4.43a4.978 4.978 0 0 1-9.14 0H3Zm5-7a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1Zm0 2a1 1 0 0 0 0 2h8a1 1 0 1 0 0-2H8Z" clip-rule="evenodd"/>
                </svg>
            },
            Icons::QuestionCircle => html! {
                <svg class={classes} aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width={str_size.clone()} height={str_size.clone()} fill="currentColor" viewBox="0 0 24 24">
                  <path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm9.008-3.018a1.502 1.502 0 0 1 2.522 1.159v.024a1.44 1.44 0 0 1-1.493 1.418 1 1 0 0 0-1.037.999V14a1 1 0 1 0 2 0v-.539a3.44 3.44 0 0 0 2.529-3.256 3.502 3.502 0 0 0-7-.255 1 1 0 0 0 2 .076c.014-.398.187-.774.48-1.044Zm.982 7.026a1 1 0 1 0 0 2H12a1 1 0 1 0 0-2h-.01Z" clip-rule="evenodd"/>
                </svg>
            },
            Icons::FileCsv => html! {
                <svg class={classes} aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width={str_size.clone()} height={str_size.clone()} fill="currentColor" viewBox="0 0 24 24">
                  <path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2 2 2 0 0 0 2 2h12a2 2 0 0 0 2-2 2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2V4a2 2 0 0 0-2-2h-7Zm1.018 8.828a2.34 2.34 0 0 0-2.373 2.13v.008a2.32 2.32 0 0 0 2.06 2.497l.535.059a.993.993 0 0 0 .136.006.272.272 0 0 1 .263.367l-.008.02a.377.377 0 0 1-.018.044.49.49 0 0 1-.078.02 1.689 1.689 0 0 1-.297.021h-1.13a1 1 0 1 0 0 2h1.13c.417 0 .892-.05 1.324-.279.47-.248.78-.648.953-1.134a2.272 2.272 0 0 0-2.115-3.06l-.478-.052a.32.32 0 0 1-.285-.341.34.34 0 0 1 .344-.306l.94.02a1 1 0 1 0 .043-2l-.943-.02h-.003Zm7.933 1.482a1 1 0 1 0-1.902-.62l-.57 1.747-.522-1.726a1 1 0 0 0-1.914.578l1.443 4.773a1 1 0 0 0 1.908.021l1.557-4.773Zm-13.762.88a.647.647 0 0 1 .458-.19h1.018a1 1 0 1 0 0-2H6.647A2.647 2.647 0 0 0 4 13.647v1.706A2.647 2.647 0 0 0 6.647 18h1.018a1 1 0 1 0 0-2H6.647A.647.647 0 0 1 6 15.353v-1.706c0-.172.068-.336.19-.457Z" clip-rule="evenodd"/>
                </svg>
            },
        }
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/icons.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/layout.rs>>
use yew::prelude::*;

use crate::components::{sidebar::SidebarItems, Icons};

use super::{footer::Footer, navbar::Navbar, sidebar::Sidebar};

#[derive(Properties, PartialEq)]
pub struct LayoutProps {
    pub children: Children,
}

#[function_component(Layout)]
pub fn layout(props: &LayoutProps) -> Html {
    let items = SidebarItems::builder()
        .link("Dashboard", "/dashboard", &Icons::PieChart.into())
        .link("Forms", "/forms", &Icons::FileLines.into())
        .link("Scans", "/scans", &Icons::InboxFull.into())
        .separator()
        .link("Support", "/support", &Icons::QuestionCircle.into())
        .build();

    html! {
        <div class="h-screen flex-grow flex flex-col">
            <Navbar />
            <div class="flex flex-grow pt-16 overflow-hidden bg-gray-50 dark:bg-gray-900">
                <Sidebar items={items} />
                <div
                    id="main-content"
                    class="flex-grow overflow-y-auto bg-gray-50 lg:ml-64 dark:bg-gray-900"
                >
                    <main>
                        { for props.children.iter() }
                    </main>
                    <Footer />
                </div>
            </div>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/layout.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/viewer.rs>>
use std::{cell::RefCell, rc::Rc};

use gloo_timers::callback::Timeout;
use gloo_utils::document;
use paperiq_types::ScanField;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::{console, HtmlElement, HtmlImageElement};
use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct ViewerProps {
    pub image: String,
    pub fields: Vec<ScanField>,
}

pub struct HighlightStyle {
    top: f64,
    left: f64,
    width: f64,
    height: f64,
}

const SCALING_FACTOR: f64 = 2.5;
const BORDER: f64 = 35.0;

#[function_component(Viewer)]
pub fn viewer(props: &ViewerProps) -> Html {
    let image_ref = use_node_ref();
    let container_ref = use_node_ref();
    let active_field = use_state(|| None::<ScanField>);
    let highlight_style = use_state(|| None::<HighlightStyle>);
    let is_loaded = use_state(|| false);
    let is_animating = use_state(|| false);

    {
        let is_animating = is_animating.clone();
        let active_field = active_field.clone();
        let fields = props.fields.clone();
        use_effect_with((), move |_| {
            let onfocuschange = Closure::wrap(Box::new(move |event: Event| {
                let target = event.target().unwrap();
                let element = target.dyn_into::<web_sys::Element>().unwrap();

                if let Some(name) = element.get_attribute("name") {
                    if let Some(field) = fields.iter().find(|f| f.name == name) {
                        active_field.set(Some(field.clone()));
                        is_animating.set(true);
                    }
                }
            }) as Box<dyn FnMut(_)>);

            console::log_1(&"add event listener".into());
            let doc = document();
            doc.add_event_listener_with_callback("focus", onfocuschange.as_ref().unchecked_ref())
                .expect("failed to add event listener");
            doc.add_event_listener_with_callback("focusin", onfocuschange.as_ref().unchecked_ref())
                .expect("failed to add focusin event listener");

            move || {
                let doc = document();
                doc.remove_event_listener_with_callback(
                    "focus",
                    onfocuschange.as_ref().unchecked_ref(),
                )
                .expect("failed to remove event listener");

                doc.remove_event_listener_with_callback(
                    "focusin",
                    onfocuschange.as_ref().unchecked_ref(),
                )
                .expect("failed to remove event listener");
            }
        });
    }

    {
        let is_animating = is_animating.clone();
        use_effect_with(is_animating.clone(), move |_| {
            let timer = Rc::new(RefCell::new(None));
            let timer_clone = timer.clone();
            let is_animating_clone = is_animating.clone();

            if *is_animating {
                *timer.borrow_mut() = Some(Timeout::new(300, move || {
                    is_animating_clone.set(false);
                }));
            }

            Box::new(move || {
                let mut timer_ref = timer_clone.borrow_mut();
                if timer_ref.is_some() {
                    *timer_ref = None;
                }
            }) as Box<dyn Fn()>
        });
    }

    {
        let is_loaded = is_loaded.clone();
        let active_field = active_field.clone();
        let highlight_style = highlight_style.clone();
        let is_animating = is_animating.clone();
        let image_ref = image_ref.clone();
        let container_ref = container_ref.clone();

        use_effect_with(
            (
                is_loaded.clone(),
                active_field.clone(),
                is_animating.clone(),
            ),
            move |(is_loaded, active_field, is_animating)| {
                let is_loaded = **is_loaded;
                let is_animating = **is_animating;

                if is_loaded && !is_animating {
                    let image = image_ref.cast::<HtmlImageElement>().unwrap();
                    let container = container_ref.cast::<HtmlElement>().unwrap();

                    if let Some(field) = active_field.as_ref() {
                        let new_style = calculate_highlight(&image, field, &container);
                        highlight_style.set(Some(new_style));
                    }
                }

                || ()
            },
        );
    }

    let is_loaded = is_loaded.clone();
    let onimageload = move |_| {
        is_loaded.set(true);
    };

    html! {
        <div class="p-4 overflow-y-auto relative" ref={container_ref}>
            <img
                ref={image_ref}
                src={format!("data:image/jpg;base64,{}", props.image)}
                class="w-full h-auto transition-transform duration-300 ease-in-out"
                onload={onimageload}
            />
            {if let Some(style) = highlight_style.as_ref() {
                let mut classes = vec![
                    "absolute",
                    "border-4",
                    "shadow-lg",
                    "pointer-events-none",
                    "transition-all",
                    "duration-300",
                    "ease-in-out",
                    "rounded-2xl",
                ];
                if let Some(active_field) = active_field.as_ref() {
                    if active_field.accuracy < 90.0 {
                        classes.push("border-red-400");
                    } else if active_field.accuracy < 95.5 {
                        classes.push("border-yellow-400");
                    } else {
                        classes.push("border-green-400");
                    }
                }
                if *is_animating {
                    classes.push("scale-110");
                } else {
                    classes.push("scale-100");
                }

                html! {
                    <div
                        class={classes!(classes)}
                        style={format!(
                            "box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5); top: {}px; left: {}px; width: {}px; height: {}px;",
                            style.top, style.left, style.width, style.height
                        )}
                    />
                }
            } else {
                html! {}
            }}
        </div>
    }
}

fn calculate_highlight(
    image: &HtmlImageElement,
    active_field: &ScanField,
    container: &HtmlElement,
) -> HighlightStyle {
    let image_width = image.width() as f64;
    let image_height = image.height() as f64;

    let x = active_field.x * image_width;
    let y = active_field.y * image_height;
    let width = active_field.width * image_width;
    let height = active_field.height * image_height;

    let center_x = x + width / 2.0;
    let center_y = y + height / 2.0;

    let container_width = container.client_width() as f64;
    let container_height = container.client_height() as f64;

    let scroll_left = center_x * SCALING_FACTOR - container_width / 2.0;
    let scroll_top = center_y * SCALING_FACTOR - container_height / 2.0;

    image
        .dyn_ref::<HtmlElement>()
        .unwrap()
        .set_attribute(
            "style",
            &format!(
                // "transform: scale({}); transform-origin: {}px {}px;",
                // SCALING_FACTOR, center_x, center_y
                "transform: scale({}); transform-origin: 0px 0px;",
                SCALING_FACTOR
            ),
        )
        .unwrap();

    container.set_scroll_left(scroll_left as i32);
    container.set_scroll_top(scroll_top as i32);

    let highlight_x = x * SCALING_FACTOR;
    let highlight_y = y * SCALING_FACTOR;

    return HighlightStyle {
        top: highlight_y - BORDER,
        left: highlight_x - BORDER,
        width: width * SCALING_FACTOR + (BORDER * 2.0),
        height: height * SCALING_FACTOR + (BORDER * 2.0),
    };
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/viewer.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/tabs.rs>>
use yew::prelude::*;
use yew_router::hooks::use_location;

#[derive(Properties, PartialEq, Clone)]
pub struct TabProps {
    pub label: String,
    pub children: Children,
    #[prop_or_default]
    pub name: Option<String>,
    #[prop_or_default]
    pub disabled: bool,
}

#[function_component(Tab)]
pub fn tab(props: &TabProps) -> Html {
    html! {
        { for props.children.iter() }
    }
}

#[derive(Properties, PartialEq)]
pub struct TabsProps {
    pub children: ChildrenWithProps<Tab>,
    #[prop_or_default]
    pub active: Option<String>,
}

#[function_component(Tabs)]
pub fn tabs(props: &TabsProps) -> Html {
    let location = use_location().unwrap();
    let active_tab = props.children.iter().position(|child| {
        if let Some(hash) = &child.props.name {
            if let Some(cur_hash) = location.hash().strip_prefix("#") {
                cur_hash == hash
            } else {
                false
            }
        } else {
            false
        }
    });
    let active_tab = use_state(|| active_tab.unwrap_or(0));

    let tabs = props.children.iter().enumerate().map(|(index, child)| {
        let child_clone = child.clone();
        let onclick = {
            let index = index;
            let active_tab = active_tab.clone();
            Callback::from(move |_| {
                if !child_clone.props.disabled {
                    active_tab.set(index);
                }
            })
        };

        let (class, aria_current) = if child.props.disabled {
            ("inline-block p-4 text-gray-400 rounded-t-lg cursor-not-allowed dark:text-gray-500".to_string(), None)
        } else if *active_tab == index {
            ("inline-block p-4 text-blue-600 border-b-2 border-blue-600 rounded-t-lg active dark:text-blue-500 dark:border-blue-500".to_string(), Some("page"))
        } else {
            ("inline-block p-4 border-b-2 border-transparent rounded-t-lg hover:text-gray-600 hover:border-gray-300 dark:hover:text-gray-300".to_string(), None)
        };

        let href = if let Some(path) = &child.props.name {
            format!("#{}", path)
        } else {
            "#".to_string()
        };
        web_sys::console::log_1(&href.clone().into());
        html! {
            <li class="me-2">
                <a href={href} {class} {onclick} aria-current={aria_current}>
                    { &child.props.label }
                </a>
            </li>
        }
    }).collect::<Html>();

    let content = props
        .children
        .iter()
        .enumerate()
        .map(|(index, child)| {
            let class = if *active_tab == index { "" } else { "hidden" };

            html! {
                <div class={class} role="tabpanel">
                    { child.props.children.clone() }
                </div>
            }
        })
        .collect::<Html>();

    html! {
        <div>
            <div class="text-sm font-medium text-center text-gray-500 border-b border-gray-200 dark:text-gray-400 dark:border-gray-700">
                <ul class="flex flex-wrap -mb-px">
                    { tabs }
                </ul>
            </div>
            <div>
                { content }
            </div>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/tabs.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/sidebar.rs>>
use yew::prelude::*;

pub struct SidebarItems {
    items: Vec<SidebarItemProps>,
}

impl SidebarItems {
    pub fn builder() -> Self {
        Self { items: Vec::new() }
    }

    pub fn link(mut self, name: &str, href: &str, icon: &Html) -> Self {
        self.items.push(SidebarItemProps {
            name: name.to_string(),
            icon: icon.clone(),
            item_type: SidebarItemType::Link(href.to_string()),
        });
        self
    }

    #[allow(unused)]
    pub fn button(mut self, name: &str, icon: Html) -> Self {
        self.items.push(SidebarItemProps {
            name: name.to_string(),
            icon,
            item_type: SidebarItemType::Button,
        });
        self
    }

    pub fn separator(mut self) -> Self {
        self.items.push(SidebarItemProps {
            name: "".to_string(),
            icon: html! {},
            item_type: SidebarItemType::Separator,
        });
        self
    }

    pub fn build(self) -> Vec<SidebarItemProps> {
        self.items
    }
}

#[allow(unused)]
#[derive(Clone, PartialEq)]
pub enum SidebarItemType {
    Link(String),
    Button,
    Separator,
}

#[derive(Clone, PartialEq, Properties)]
pub struct SidebarItemProps {
    pub name: String,
    pub icon: Html,
    pub item_type: SidebarItemType,
}

#[derive(Properties, PartialEq)]
pub struct SidebarProps {
    pub items: Vec<SidebarItemProps>,
}

#[function_component(Sidebar)]
pub fn sidebar(props: &SidebarProps) -> Html {
    html! {
    <>
        <aside
          id="sidebar"
          class="fixed top-0 left-0 z-20 flex flex-col flex-shrink-0 hidden w-64 h-full pt-16 font-normal duration-75 lg:flex transition-width"
          aria-label="Sidebar"
        >
          <div
            class="relative flex flex-col flex-1 min-h-0 pt-0 bg-white border-r border-gray-200 dark:bg-gray-800 dark:border-gray-700"
          >
            <div class="flex flex-col flex-1 pt-5 pb-4 overflow-y-auto">
              <div
                class="flex-1 px-3 space-y-1 bg-white divide-y divide-gray-200 dark:bg-gray-800 dark:divide-gray-700"
              >
                <ul class="pb-2 space-y-2">
                    {props.items.iter().map(|item| {
                        match &item.item_type {
                            SidebarItemType::Link(href) => html! {
                                <li>
                                    <a
                                        href={href.clone()}
                                        class="flex items-center p-2 text-base text-gray-900 rounded-lg hover:bg-gray-100 group dark:text-gray-200 dark:hover:bg-gray-700"
                                    >
                                        {item.icon.clone()}
                                        <span class="ml-3" sidebar-toggle-item="true">{&item.name}</span>
                                    </a>
                                </li>
                            },
                            SidebarItemType::Button => html! {
                                <li>
                                    <button
                                        type="button"
                                        class="flex items-center w-full p-2 text-base text-gray-900 transition duration-75 rounded-lg group hover:bg-gray-100 dark:text-gray-200 dark:hover:bg-gray-700"
                                        aria-controls={format!("dropdown-{}", item.name)}
                                        data-collapse-toggle={format!("dropdown-{}", item.name)}
                                    >
                                        {item.icon.clone()}
                                        <span class="ml-3" sidebar-toggle-item="true">{&item.name}</span>
                                    </button>
                                </li>
                            },
                            SidebarItemType::Separator => html! {
                                <li class="pt-2 mt-2 space-y-2 border-t border-gray-200 dark:border-gray-700">
                                </li>
                            },
                        }
                    }).collect::<Html>()}
                </ul>
              </div>
            </div>
            <div
              class="absolute bottom-0 left-0 justify-center hidden w-full p-4 space-x-4 bg-white lg:flex dark:bg-gray-800"
              sidebar-bottom-menu="true"
            >
              <a
                href="#"
                class="inline-flex justify-center p-2 text-gray-500 rounded cursor-pointer hover:text-gray-900 hover:bg-gray-100 dark:hover:bg-gray-700 dark:hover:text-white"
              >
                <svg
                  class="w-6 h-6"
                  fill="currentColor"
                  viewBox="0 0 20 20"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M5 4a1 1 0 00-2 0v7.268a2 2 0 000 3.464V16a1 1 0 102 0v-1.268a2 2 0 000-3.464V4zM11 4a1 1 0 10-2 0v1.268a2 2 0 000 3.464V16a1 1 0 102 0V8.732a2 2 0 000-3.464V4zM16 3a1 1 0 011 1v7.268a2 2 0 010 3.464V16a1 1 0 11-2 0v-1.268a2 2 0 010-3.464V4a1 1 0 011-1z"
                  ></path>
                </svg>
              </a>
              <a
                href="/"
                data-tooltip-target="tooltip-settings"
                class="inline-flex justify-center p-2 text-gray-500 rounded cursor-pointer hover:text-gray-900 hover:bg-gray-100 dark:hover:bg-gray-700 dark:hover:text-white"
              >
                <svg
                  class="w-6 h-6"
                  fill="currentColor"
                  viewBox="0 0 20 20"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    fill-rule="evenodd"
                    d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z"
                    clip-rule="evenodd"
                  ></path>
                </svg>
              </a>
              <div
                id="tooltip-settings"
                role="tooltip"
                class="absolute z-10 invisible inline-block px-3 py-2 text-sm font-medium text-white transition-opacity duration-300 bg-gray-900 rounded-lg shadow-sm opacity-0 tooltip dark:bg-gray-700"
              >
                    {"Settings page"}
                <div class="tooltip-arrow" data-popper-arrow="true"></div>
              </div>
            </div>
          </div>
        </aside>

        <div
          class="fixed inset-0 z-10 hidden bg-gray-900/50 dark:bg-gray-900/90"
          id="sidebarBackdrop"
        ></div>
    </>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/sidebar.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/breadcrumb.rs>>
use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct BreadcrumbProps {
    pub items: Vec<(String, Option<String>)>,
}

#[function_component(Breadcrumb)]
pub fn breadcrumb(props: &BreadcrumbProps) -> Html {
    html! {
        <div class="grid grid-cols-1 px-4 pt-6 xl:grid-cols-3 xl:gap-4 dark:bg-gray-900">
            <nav class="flex mb-5" aria-label="Breadcrumb">
                <ol class="inline-flex items-center space-x-1 text-sm font-medium md:space-x-2">
                    {props.items.iter().enumerate().map(|(index, (name, link))| {
                        html! {
                            <li key={index} class={if index > 0 { "flex items-center" } else { "inline-flex items-center" }}>
                                {if index > 0 {
                                    html! {
                                        <svg class="w-6 h-6 text-gray-400" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                            <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
                                        </svg>
                                    }
                                } else {
                                    html! {}
                                }}
                                {match link {
                                    Some(href) => html! {
                                        <a href={href.clone()} class="inline-flex items-center text-gray-700 hover:text-primary-600 dark:text-gray-300 dark:hover:text-primary-500">
                                            {if index == 0 {
                                                html! {
                                                    <svg class="w-5 h-5 mr-2.5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                                        <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path>
                                                    </svg>
                                                }
                                            } else {
                                                html! {}
                                            }}
                                            {name}
                                        </a>
                                    },
                                    None => html! {
                                        <span class="ml-1 text-gray-400 md:ml-2 dark:text-gray-500" aria-current="page">{name}</span>
                                    },
                                }}
                            </li>
                        }
                    }).collect::<Html>()}
                </ol>
            </nav>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/breadcrumb.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/grid.rs>>
use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct GridProps {
    #[prop_or_default]
    pub cols: Option<u8>,
    #[prop_or_default]
    pub sm: Option<u8>, // 640px
    #[prop_or_default]
    pub md: Option<u8>, // 768px
    #[prop_or_default]
    pub lg: Option<u8>, // 1024px
    #[prop_or_default]
    pub xl: Option<u8>, // 1280px
    #[prop_or_default]
    pub xxl: Option<u8>, // 1536px
    #[prop_or_default]
    pub class: Option<String>,
    pub children: Children,
}

#[function_component(Grid)]
pub fn grid(props: &GridProps) -> Html {
    let class = props.class.clone().unwrap_or("gap-4".to_string());
    let mut classes = vec!["grid".to_string(), class];
    if let Some(cols) = props.cols {
        classes.push(format!("grid-cols-{}", cols));
    }
    if let Some(cols) = props.sm {
        classes.push(format!("sm:grid-cols-{}", cols));
    }
    if let Some(cols) = props.md {
        classes.push(format!("md:grid-cols-{}", cols));
    }
    if let Some(cols) = props.lg {
        classes.push(format!("lg:grid-cols-{}", cols));
    }
    if let Some(cols) = props.xl {
        classes.push(format!("xl:grid-cols-{}", cols));
    }
    if let Some(cols) = props.xxl {
        classes.push(format!("2xl:grid-cols-{}", cols));
    }
    html! {
        <div class={classes!(classes)}>
            { for props.children.iter() }
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/grid.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/mod.rs>>
mod avatar;
mod breadcrumb;
mod button;
mod card;
mod data_table;
mod dropdown;
mod file_uploader;
mod footer;
mod grid;
mod icons;
mod layout;
mod loader;
mod modal;
mod navbar;
mod progress;
mod request_loader;
mod scans_table;
mod select;
mod sidebar;
mod table;
mod tabs;
mod user_avatar;
mod viewer;

pub use avatar::Avatar;
pub use breadcrumb::Breadcrumb;
pub use button::{Button, ButtonSize};
pub use card::Card;
pub use data_table::{DataTable, FinalStateChecker, RowTransformer};
#[allow(unused_imports)]
pub use dropdown::Dropdown;
pub use file_uploader::{FileUploader, RenderType};
pub use grid::Grid;
pub use icons::Icons;
pub use layout::Layout;
pub use loader::Loader;
pub use modal::Modal;
#[allow(unused_imports)]
pub use progress::Progress;
pub use request_loader::RequestLoader;
pub use scans_table::ScansTable;
pub use select::Select;
pub use table::{RowType, Table};
pub use tabs::{Tab, Tabs};
pub use user_avatar::UserAvatar;
pub use viewer::Viewer;

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/mod.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/request_loader.rs>>
use std::future::Future;

use gloo_timers::callback::Timeout;
use yew::prelude::*;

use crate::components::{Loader, Progress};
use crate::models::ScanRequest;

#[derive(Properties, Clone, PartialEq)]
pub struct RequestLoaderProps {
    pub request: Callback<(), std::pin::Pin<Box<dyn Future<Output = anyhow::Result<ScanRequest>>>>>,
    pub render: Callback<ScanRequest, Html>,
}

#[function_component(RequestLoader)]
pub fn request_loader(props: &RequestLoaderProps) -> Html {
    let RequestLoaderProps { request, render } = props;

    let error = use_state(|| None::<String>);
    let data = use_state(|| None);
    let should_fetch = use_state(|| true);

    {
        let error = error.clone();
        let data = data.clone();
        let should_fetch = should_fetch.clone();
        let request = request.clone();

        use_effect_with(*should_fetch, move |inner_should_fetch| {
            if *inner_should_fetch {
                wasm_bindgen_futures::spawn_local(async move {
                    match request.emit(()).await {
                        Ok(scan) => {
                            error.set(None);
                            if !scan.is_finished() {
                                // Schedule next fetch after 5 seconds
                                let should_fetch = should_fetch.clone();
                                Timeout::new(5_000, move || {
                                    should_fetch.set(true);
                                })
                                .forget();
                            }
                            data.set(Some(scan));
                        }
                        Err(e) => {
                            error.set(Some(e.to_string()));
                            data.set(None);
                        }
                    }
                    should_fetch.set(false);
                });
            }
            || ()
        });
    }

    {
        match data.as_ref() {
            Some(scan) => {
                if scan.in_progress() {
                    html! { <ScanProgress scan={(*scan).clone()}/> }
                } else {
                    render.emit(scan.clone())
                }
            }
            None => match error.as_ref() {
                Some(err) => html! { err },
                None => html! { <Loader /> },
            },
        }
    }
}

#[derive(Properties, Clone, PartialEq)]
pub struct ScanProgressProps {
    pub scan: ScanRequest,
}

#[function_component(ScanProgress)]
fn scan_progress(props: &ScanProgressProps) -> Html {
    let props = props.clone();

    html! {
        <div class="flex items-center justify-center h-full">
            <Progress id={props.scan.id} />
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/request_loader.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/progress.rs>>
use crate::components::Loader;
use crate::http::{self, Result};
use crate::models::ScanRequest;
use gloo_timers::callback::Interval;
use web_sys::console;
use yew::prelude::*;

#[derive(Properties, Clone, PartialEq)]
pub struct ProgressProps {
    pub id: i32,
}

#[function_component(Progress)]
pub fn progress(props: &ProgressProps) -> Html {
    let id = props.id;
    let progress = use_state(|| 0);
    let request_state = use_state(|| None);

    {
        let progress = progress.clone();
        let request_state = request_state.clone();
        use_effect_with((), move |_| {
            let interval = Interval::new(1000, move || {
                let progress = progress.clone();
                let request_state = request_state.clone();
                wasm_bindgen_futures::spawn_local(async move {
                    match get_request(id).await {
                        Ok(request) => {
                            progress.set(request.percentage);
                            request_state.set(Some(request));
                        }
                        Err(err) => {
                            console::error_1(&format!("Failed to fetch request: {}", err).into());
                        }
                    }
                });
            });

            || {
                interval.cancel();
            }
        });
    }

    html! {
        <div class="grid grid-col-1 w-full">
            <div class="w-full flex flex-col items-center justify-center text-gray-400 p-2 text-center text-gray-400 p-2">
                <Loader />
                <div class="p-2 text-lg">
                    {"Please wait while we process your document..."}
                </div>
            </div>
            <div class="w-full bg-gray-200 rounded-full 2.5 dark:bg-gray-700">
                <div
                    class="bg-blue-600 text-xs font-medium text-center text-blue-100 leading-none p-0.5 rounded-full transition-all duration-300 ease-in-out"
                    style={format!("width: {}%", *progress)}
                >
                    {format!(" {}%", *progress)}
                </div>
            </div>
        </div>
    }
}

async fn get_request(id: i32) -> Result<ScanRequest> {
    let response = http::get(&format!("/api/requests/{}", id)).await?;
    let request: ScanRequest = response.json().await?;
    Ok(request)
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/progress.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/select.rs>>
use yew::prelude::*;

type SelectOption = (String, String);

#[derive(Properties, PartialEq)]
pub struct SelectProps {
    pub label: String,
    pub options: Vec<SelectOption>,
    pub on_change: Callback<String>,
    #[prop_or_default]
    pub placeholder: Option<String>,
}

#[function_component(Select)]
pub fn select(props: &SelectProps) -> Html {
    let selected_value = use_state(String::new);

    let onchange = {
        let on_change = props.on_change.clone();
        let selected_value = selected_value.clone();
        Callback::from(move |e: Event| {
            let value = e
                .target_unchecked_into::<web_sys::HtmlSelectElement>()
                .value();
            selected_value.set(value.clone());
            on_change.emit(value);
        })
    };

    // calls the callback with the first value
    {
        let value = props.options.first().unwrap().0.clone();
        let on_change = props.on_change.clone();
        use_effect_with((), move |_| {
            on_change.emit(value);
        });
    }

    html! {
        <div class="max-w-sm mx-auto">
            <label for="select-input" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">
                {&props.label}
            </label>
            <select
                id="select-input"
                class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
                {onchange}
            >
                if let Some(placeholder) = &props.placeholder {
                    <option selected=true value="">
                        {placeholder}
                    </option>
                }
                {for props.options.iter().map(|option| html! {
                    <option value={option.0.clone()} selected={*selected_value == option.0}>
                        {&option.1}
                    </option>
                })}
            </select>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/select.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/data_table.rs>>
use std::{rc::Rc, time::Duration};

use super::RowType;
use crate::{
    components::{Loader, Table},
    http::get,
};
use gloo_timers::callback::Interval;
use serde_json::Value;
use web_sys::console;
use yew::prelude::*;

#[derive(Clone)]
pub struct FinalStateChecker(Rc<dyn Fn(&Value) -> bool>);

impl FinalStateChecker {
    pub fn new<F>(f: F) -> Self
    where
        F: Fn(&Value) -> bool + 'static,
    {
        FinalStateChecker(Rc::new(f))
    }

    pub fn check(&self, value: &Value) -> bool {
        (self.0)(value)
    }
}

impl PartialEq for FinalStateChecker {
    fn eq(&self, _other: &Self) -> bool {
        false
    }
}

#[derive(Clone)]
pub struct RowTransformer(Rc<dyn Fn(Value) -> anyhow::Result<Vec<RowType>>>);

impl PartialEq for RowTransformer {
    fn eq(&self, _other: &Self) -> bool {
        true
    }
}

impl RowTransformer {
    pub fn new<F>(f: F) -> Self
    where
        F: Fn(Value) -> anyhow::Result<Vec<RowType>> + 'static,
    {
        RowTransformer(Rc::new(f))
    }

    pub fn call(&self, value: Value) -> anyhow::Result<Vec<RowType>> {
        (self.0)(value)
    }
}

#[derive(Properties, PartialEq)]
pub struct DataTableProps {
    pub endpoint: String,
    pub headers: Vec<String>,
    pub row_transformer: RowTransformer,
    #[prop_or_default]
    pub onrowclick: Option<Callback<Value>>,
    #[prop_or(Duration::from_secs(5))]
    pub refresh_interval: Duration,
    #[prop_or_default]
    pub is_final_state: Option<FinalStateChecker>,
}

#[function_component(DataTable)]
pub fn data_table(props: &DataTableProps) -> Html {
    let data = use_state(|| None);
    let rows = use_state(|| None);
    let should_poll = use_state(|| true);
    let endpoint = props.endpoint.clone();
    let row_transformer = props.row_transformer.clone();
    let is_final_state = props.is_final_state.clone();
    let refresh_interval = props.refresh_interval.clone();

    {
        let rows = rows.clone();
        let data = data.clone();
        let endpoint = endpoint.clone();
        let row_transformer = row_transformer.clone();
        let should_poll = should_poll.clone();
        let is_final_state = is_final_state.clone();
        let refresh_interval = refresh_interval.clone();

        use_effect_with((), move |_| {
            let fetch_data = {
                let rows = rows.clone();
                let data = data.clone();
                let endpoint = endpoint.clone();
                let row_transformer = row_transformer.clone();
                let should_poll = should_poll.clone();
                let is_final_state = is_final_state.clone();

                Rc::new(move || {
                    let rows = rows.clone();
                    let data = data.clone();
                    let endpoint = endpoint.clone();
                    let row_transformer = row_transformer.clone();
                    let should_poll = should_poll.clone();
                    let is_final_state = is_final_state.clone();

                    wasm_bindgen_futures::spawn_local(async move {
                        match get_rows(&endpoint, &row_transformer).await {
                            Ok((in_data, in_rows)) => {
                                data.set(Some(in_data.clone()));
                                rows.set(Some(in_rows));

                                // Check if all rows are in final state
                                if let Some(checker) = &is_final_state {
                                    let all_final = in_data.iter().all(|row| checker.check(row));
                                    should_poll.set(!all_final);
                                }
                            }
                            Err(err) => {
                                console::log_1(&format!("Error fetching data: {}", err).into());
                            }
                        }
                    });
                })
            };

            // Initial fetch
            fetch_data();

            // Set up polling
            let interval = Interval::new(refresh_interval.as_millis() as u32, move || {
                if *should_poll {
                    fetch_data();
                }
            });

            // Clean up the interval when the component is unmounted
            move || drop(interval)
        });
    }

    if let Some(rows) = rows.as_ref() {
        let onrowclick = {
            let onrowclick = props.onrowclick.clone();
            Callback::from(move |index: usize| {
                if let Some(onrowclick) = &onrowclick {
                    if let Some(data) = data.as_ref() {
                        onrowclick.emit(data[index].clone());
                    }
                }
            })
        };

        html! {
            <Table
                headers={props.headers.clone()}
                rows={rows.clone()}
                onrowclick={onrowclick}
            />
        }
    } else {
        html! { <Loader /> }
    }
}

async fn get_rows(
    endpoint: &str,
    row_transformer: &RowTransformer,
) -> anyhow::Result<(Vec<Value>, Vec<Vec<RowType>>)> {
    let resp = get(endpoint).await?;
    let rows: Value = resp.json().await?;
    let Value::Array(rows) = rows else {
        anyhow::bail!("expected array");
    };
    let mut result = Vec::new();
    for row in &rows {
        result.push(row_transformer.call(row.clone())?);
    }
    Ok((rows, result))
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/data_table.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/user_avatar.rs>>
use web_sys::console;
use yew::prelude::*;

use crate::components::{Avatar, Loader};
use crate::contexts::UserContext;

#[function_component(UserAvatar)]
pub fn user_avatar() -> Html {
    let user_ctx = use_context::<UserContext>().expect("No user context found");
    let user_state = &*user_ctx.state;

    console::log_1(&format!("user_state: {:?}", user_state).into());

    if user_state.is_loading {
        html! { <Loader /> }
    } else if let Some(user) = &user_state.user {
        html! {
            <Avatar email={user.email.clone()} size={32} />
        }
    } else {
        html! { <div>{"User not found"}</div> }
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/user_avatar.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/table.rs>>
use chrono::{TimeZone, Utc};
use chrono_humanize::HumanTime;
use js_sys::Array;
use wasm_bindgen::{JsCast, JsValue};
use web_sys::{Blob, HtmlAnchorElement, Url};
use yew::prelude::*;

use crate::components::{Button, ButtonSize, Icons};

#[derive(Clone, PartialEq, Debug)]
pub enum RowType {
    DateTime(chrono::NaiveDateTime),
    String(String),
    Html(Html),
}

impl From<serde_json::Value> for RowType {
    fn from(value: serde_json::Value) -> Self {
        match value {
            serde_json::Value::String(s) => RowType::String(s),
            serde_json::Value::Number(n) => RowType::String(n.to_string()),
            serde_json::Value::Bool(b) => RowType::String(b.to_string()),
            serde_json::Value::Null => RowType::String("null".to_string()),
            serde_json::Value::Array(_) | serde_json::Value::Object(_) => unimplemented!(),
        }
    }
}

impl ToHtml for RowType {
    fn to_html(&self) -> Html {
        match self {
            RowType::DateTime(dt) => {
                let datetime_utc = Utc.from_utc_datetime(&dt);
                let now = Utc::now();
                let human_time = if datetime_utc < now {
                    HumanTime::from(datetime_utc - now)
                } else {
                    HumanTime::from(now - datetime_utc)
                };
                html! { human_time }
            }
            RowType::String(s) => html! { s },
            RowType::Html(h) => h.clone(),
        }
    }
}

impl From<String> for RowType {
    fn from(s: String) -> Self {
        RowType::String(s)
    }
}

impl From<&str> for RowType {
    fn from(s: &str) -> Self {
        RowType::String(s.to_string())
    }
}

impl From<Html> for RowType {
    fn from(h: Html) -> Self {
        RowType::Html(h)
    }
}

impl From<chrono::NaiveDateTime> for RowType {
    fn from(dt: chrono::NaiveDateTime) -> Self {
        RowType::DateTime(dt)
    }
}

#[derive(Properties, PartialEq)]
pub struct TableProps {
    pub headers: Vec<String>,
    pub rows: Vec<Vec<RowType>>,
    #[prop_or_default]
    pub csv_download: bool,
    #[prop_or_default]
    pub onrowclick: Option<Callback<usize>>,
}

#[function_component(Table)]
pub fn table(props: &TableProps) -> Html {
    let download_csv = {
        let headers = props.headers.clone();
        let rows = props.rows.clone();
        Callback::from(move |_| {
            let mut csv_content = String::new();

            // Add headers
            csv_content.push_str(&headers.join(","));
            csv_content.push_str("\n");

            // Add rows
            for row in &rows {
                let row_content: Vec<String> = row
                    .iter()
                    .map(|cell| match cell {
                        RowType::DateTime(dt) => dt.to_string(),
                        RowType::String(s) => s.clone(),
                        RowType::Html(_) => "HTML Content".to_string(), // Placeholder for HTML content
                    })
                    .collect();
                csv_content.push_str(&row_content.join(","));
                csv_content.push_str("\n");
            }

            // Create a Blob with the CSV content
            let blob = Blob::new_with_str_sequence_and_options(
                &Array::of1(&JsValue::from_str(&csv_content)),
                web_sys::BlobPropertyBag::new().type_("text/csv;charset=utf-8;"),
            )
            .unwrap();

            // Create a download URL
            let url = Url::create_object_url_with_blob(&blob).unwrap();

            // Create a temporary anchor element and trigger the download
            let document = web_sys::window().unwrap().document().unwrap();
            let anchor = document
                .create_element("a")
                .unwrap()
                .dyn_into::<HtmlAnchorElement>()
                .unwrap();
            anchor.set_href(&url);
            anchor.set_download("table_data.csv");
            anchor.click();

            // Clean up
            Url::revoke_object_url(&url).unwrap();
        })
    };

    html! {
    <div class="overflow-x-auto">
        { if props.csv_download {
            html! {
                <div class="mb-4">
                    <Button
                        text="Download CSV"
                        icon={Icons::FileCsv}
                        size={ButtonSize::ExtraSmall}
                        on_click={download_csv}
                    />
                </div>
            }
        } else {
            html! {}
        } }
        <table class="min-w-full divide-y divide-gray-200 table-fixed dark:divide-gray-600">
            <thead class="bg-gray-100 dark:bg-gray-700">
                <tr>
                    { for props.headers.iter().map(|header| html! {
                        <th scope="col" class="p-4 text-xs font-medium text-left text-gray-500 uppercase dark:text-gray-400">
                            { header }
                        </th>
                    }) }
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200 dark:bg-gray-800 dark:divide-gray-700">
                { for props.rows.iter().enumerate().map(|(index, row)| {
                    let row_index = index;
                    let onclick = props.onrowclick.clone().map(move |callback| {
                        Callback::from(move |_| callback.emit(row_index))
                    });
                    html! {
                        <tr
                            class="hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer transition-colors duration-200"
                            onclick={onclick}
                        >
                            { for row.iter().map(|cell| html! {
                                <td class="items-center p-4 mr-12 space-x-6 whitespace-nowrap">
                                    { cell }
                                </td>
                            })}
                        </tr>
                    }
                })}
            </tbody>
        </table>
    </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/table.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/dropdown.rs>>
use yew::prelude::*;

pub type DropdownItem = (String, String);

#[derive(Properties, PartialEq)]
pub struct DropdownProps {
    pub items: Vec<DropdownItem>,
    pub on_select: Callback<String>,
}

#[function_component(Dropdown)]
pub fn dropdown(props: &DropdownProps) -> Html {
    let dropdown_visible = use_state(|| false);

    let onclick_toggle = {
        let dropdown_visible = dropdown_visible.clone();
        Callback::from(move |_| {
            dropdown_visible.set(!*dropdown_visible);
        })
    };

    let onclick_item = {
        let on_select = props.on_select.clone();
        let dropdown_visible = dropdown_visible.clone();
        Callback::from(move |value: String| {
            on_select.emit(value);
            dropdown_visible.set(false);
        })
    };

    html! {
        <div class="relative inline-block text-left">
            <button
                onclick={onclick_toggle}
                class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center inline-flex items-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800"
                type="button"
            >
                {"Dropdown button"}
                <svg class="w-2.5 h-2.5 ms-3" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6">
                    <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m1 1 4 4 4-4"/>
                </svg>
            </button>
            if *dropdown_visible {
                <div class="absolute right-0 z-10 mt-2 w-44 origin-top-right rounded-lg bg-white shadow-lg ring-1 ring-black ring-opacity-5 dark:bg-gray-700">
                    <ul class="py-2 text-sm text-gray-700 dark:text-gray-200">
                        {for props.items.iter().map(|item| {
                            let value = item.0.clone();
                            let onclick = onclick_item.reform(move |_| value.clone());
                            html! {
                                <li>
                                    <a
                                        href="#"
                                        onclick={onclick}
                                        class="block px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-600 dark:hover:text-white"
                                    >
                                        {&item.0}
                                    </a>
                                </li>
                            }
                        })}
                    </ul>
                </div>
            }
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/dropdown.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/footer.rs>>
use yew::prelude::*;

#[function_component(Footer)]
pub fn footer() -> Html {
    html! {<></>}
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/footer.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/file_uploader.rs>>
use std::rc::Rc;
use std::{cell::RefCell, collections::HashMap};

use base64::{engine::general_purpose, Engine as _};
use serde::{Deserialize, Serialize};
use serde_json::json;
use wasm_bindgen::closure::Closure;
use wasm_bindgen::JsCast;
use web_sys::{
    console,
    js_sys::{ArrayBuffer, Uint8Array},
    DragEvent, Event, File, FileReader, HtmlInputElement, ProgressEvent,
};
use yew::prelude::*;

use crate::components::{Button, ButtonSize};
use crate::http::post;

#[derive(Properties, Clone, PartialEq)]
pub struct FileUploaderProps {
    pub url: String,
    pub prompt: String,
    #[prop_or_default]
    pub class: Option<String>,
    #[prop_or_default]
    pub message: Option<String>,
    #[prop_or_default]
    pub subtitle: Option<String>,
    #[prop_or_default]
    pub onupload: Option<Callback<i32>>,
    #[prop_or_default]
    pub attributes: Option<HashMap<String, serde_json::Value>>,
    #[prop_or_default]
    pub allowed_types: Option<Vec<String>>,
    #[prop_or(RenderType::Div)]
    pub render_type: RenderType,
    #[prop_or_default]
    pub button_text: Option<String>,
    #[prop_or(ButtonSize::Base)]
    pub button_size: ButtonSize,
}

#[derive(Clone, PartialEq)]
pub enum RenderType {
    Div,
    Button,
}

#[derive(Serialize, Deserialize)]
struct ScanResponse {
    id: i32,
}

#[function_component(FileUploader)]
pub fn file_uploader(props: &FileUploaderProps) -> Html {
    let upload_status = use_state(|| String::new());
    let is_dragging = use_state(|| false);
    let file_input_ref = use_node_ref();

    let allowed_types = props
        .allowed_types
        .clone()
        .unwrap_or_else(|| vec!["*/*".to_string()]);
    let accept_string = allowed_types.join(",");
    let classes = props.class.clone();

    let is_file_type_valid = move |file: &File| -> bool {
        if allowed_types.contains(&"*/*".to_string()) {
            return true;
        }
        allowed_types.iter().any(|allowed_type| {
            file.type_().starts_with(allowed_type)
                || (allowed_type.starts_with(".") && file.name().ends_with(allowed_type))
        })
    };
    let process_file = {
        let upload_status = upload_status.clone();
        let url = props.url.clone();
        let prompt = props.prompt.clone();
        let onupload = props.onupload.clone();
        let attributes = props.attributes.clone();
        Callback::from(move |file: File| {
            if !is_file_type_valid(&file) {
                upload_status
                    .set("Invalid file type. Please select an allowed file type.".to_string());
                return;
            }

            let upload_status = Rc::new(RefCell::new(upload_status.clone()));
            let onupload = onupload.clone();
            let reader = FileReader::new().unwrap();
            let url = url.clone();
            let prompt = prompt.clone();
            let attributes = attributes.clone();
            let file_name = file.name();
            let onload = Closure::wrap(Box::new(move |e: ProgressEvent| {
                let reader: FileReader = e.target().unwrap().dyn_into().unwrap();
                match reader.result() {
                    Ok(result) => {
                        if let Some(array_buffer) = result.dyn_into::<ArrayBuffer>().ok() {
                            let uint8_array = Uint8Array::new(&array_buffer);
                            let vec: Vec<u8> = uint8_array.to_vec();
                            let base64 = general_purpose::STANDARD.encode(&vec);

                            // Process the file immediately
                            let upload_status_clone = Rc::clone(&upload_status);
                            let onupload_clone = onupload.clone();
                            let url = url.clone();
                            let prompt = prompt.clone();
                            let attributes = attributes.clone();
                            let file_name = file_name.clone();

                            wasm_bindgen_futures::spawn_local(async move {
                                let mut payload = json!({
                                    "prompt": prompt,
                                    "images": [base64],
                                    "file_names": [file_name],
                                });

                                if let Some(attrs) = attributes {
                                    for (key, value) in attrs {
                                        payload[key] = value.clone();
                                    }
                                }

                                match post(&url, &payload).await {
                                    Ok(response) => {
                                        if response.ok() {
                                            upload_status_clone
                                                .borrow_mut()
                                                .set("File uploaded successfully".to_string());
                                            // parse response body
                                            let body: ScanResponse = response.json().await.unwrap();
                                            if let Some(callback) = onupload_clone {
                                                callback.emit(body.id);
                                            }
                                        } else {
                                            upload_status_clone.borrow_mut().set(format!(
                                                "Upload failed: {}",
                                                response.status()
                                            ));
                                        }
                                    }
                                    Err(err) => {
                                        upload_status_clone
                                            .borrow_mut()
                                            .set(format!("Upload error: {}", err));
                                    }
                                }
                            });
                        } else {
                            console::log_1(&"Failed to convert result to ArrayBuffer".into());
                        }
                    }
                    Err(err) => {
                        console::log_1(&format!("Error reading file: {:?}", err).into());
                    }
                }
            }) as Box<dyn FnMut(ProgressEvent)>);
            reader.set_onload(Some(onload.as_ref().unchecked_ref()));
            reader
                .read_as_array_buffer(&file)
                .expect("Failed to read file");
            onload.forget();
        })
    };

    let trigger_file_input = {
        let file_input_ref = file_input_ref.clone();
        Callback::from(move |_: MouseEvent| {
            if let Some(input) = file_input_ref.cast::<HtmlInputElement>() {
                input.click();
            }
        })
    };

    let onchange = {
        let process_file = process_file.clone();
        Callback::from(move |e: Event| {
            let input: HtmlInputElement = e.target_unchecked_into();
            if let Some(file) = input.files().and_then(|files| files.get(0)) {
                process_file.emit(file);
            }
        })
    };

    let ondragover = {
        let is_dragging = is_dragging.clone();
        Callback::from(move |e: DragEvent| {
            e.prevent_default();
            is_dragging.set(true);
        })
    };

    let ondragleave = {
        let is_dragging = is_dragging.clone();
        Callback::from(move |e: DragEvent| {
            e.prevent_default();
            is_dragging.set(false);
        })
    };

    let ondrop = {
        let is_dragging = is_dragging.clone();
        let process_file = process_file.clone();
        Callback::from(move |e: DragEvent| {
            e.prevent_default();
            is_dragging.set(false);
            if let Some(dt) = e.data_transfer() {
                if let Some(files) = dt.files() {
                    if let Some(file) = files.get(0) {
                        process_file.emit(file);
                    }
                }
            }
        })
    };

    let mut drop_zone_class = vec![
        "border-2".to_string(),
        "border-dashed".to_string(),
        "border-gray-600".to_string(),
        "p-20".to_string(),
        "mb-4".to_string(),
        "text-center".to_string(),
        "cursor-pointer".to_string(),
        "rounded-lg".to_string(),
        "dark:text-gray-400".to_string(),
    ];
    if *is_dragging {
        drop_zone_class.push("border-blue-500".to_string());
    };

    let message = match &props.message {
        Some(message) => message.clone(),
        None => "Drag and drop a file here or click to select".to_string(),
    };

    let button_text = props
        .button_text
        .clone()
        .unwrap_or_else(|| "Upload File".to_string());

    html! {
        <div>
            {
                match props.render_type {
                    RenderType::Div => html! {
                        <label for="file-input">
                            <div
                                class={drop_zone_class}
                                ondragover={ondragover}
                                ondragleave={ondragleave}
                                ondrop={ondrop}
                            >
                                <center>
                                    <svg class="w-[70px] h-[70px] text-gray-800 dark:text-blue-400 text-center mb-8" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
                                      <path fill-rule="evenodd" d="M12 3a1 1 0 0 1 .78.375l4 5a1 1 0 1 1-1.56 1.25L13 6.85V14a1 1 0 1 1-2 0V6.85L8.78 9.626a1 1 0 1 1-1.56-1.25l4-5A1 1 0 0 1 12 3ZM9 14v-1H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2h-4v1a3 3 0 1 1-6 0Zm8 2a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H17Z" clip-rule="evenodd"/>
                                    </svg>
                                </center>
                                <p class="text-gray-800 dark:text-gray-400 text-xl font-bold">
                                    {message}
                                </p>
                                { if let Some(subtitle) = &props.subtitle {
                                    html! { <p class="text-gray-500 dark:text-gray-400 text-sm mt-2">{subtitle}</p> }
                                } else {
                                    html! {}
                                }}
                            </div>
                        </label>
                    },
                    RenderType::Button => html! {
                        <Button
                            class={classes}
                            on_click={trigger_file_input}
                            text={button_text}
                            size={props.button_size.clone()}
                        />
                    }
                }
            }
            <input
                id="file-input"
                type="file"
                ref={file_input_ref}
                style="display: none;"
                accept={accept_string}
                onchange={onchange}
            />
            <p>{&*upload_status}</p>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/file_uploader.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/loader.rs>>
use yew::prelude::*;

#[function_component(Loader)]
pub fn loader() -> Html {
    html! {
        <div role="status">
            <svg aria-hidden="true" class="w-8 h-8 text-gray-200 animate-spin dark:text-gray-600 fill-blue-600" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"/>
                <path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"/>
            </svg>
            <span class="sr-only">{"Loading..."}</span>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/loader.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/modal.rs>>
use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct ModalProps {
    pub title: String,
    pub is_open: bool,
    pub on_close: Callback<MouseEvent>,
    #[prop_or_default]
    pub on_accept: Option<Callback<MouseEvent>>,
    #[prop_or_default]
    pub on_decline: Option<Callback<MouseEvent>>,
    #[prop_or_default]
    pub hide_actions: bool,
    #[prop_or_default]
    pub ok_label: Option<String>,
    #[prop_or_default]
    pub cancel_label: Option<String>,
    #[prop_or_default]
    pub children: Children,
}

#[function_component(Modal)]
pub fn modal(props: &ModalProps) -> Html {
    let ok_label = props.ok_label.clone().unwrap_or_else(|| "Ok".to_string());
    let cancel_label = props
        .cancel_label
        .clone()
        .unwrap_or_else(|| "Cancel".to_string());
    let modal_class = if props.is_open {
        "fixed inset-0 z-50 flex items-center justify-center overflow-x-hidden overflow-y-auto outline-none focus:outline-none"
    } else {
        "hidden"
    };

    html! {
        <div class={modal_class}>
            <div class="relative w-auto max-w-2xl mx-auto my-6">
                <div class="relative flex flex-col w-full bg-white border-0 rounded-lg shadow-lg outline-none focus:outline-none dark:bg-gray-700">
                    // Modal header
                    <div class="flex items-start justify-between p-5 border-b border-solid rounded-t border-blueGray-200 dark:border-gray-600">
                        <h3 class="text-xl font-semibold text-gray-900 dark:text-white">
                            {&props.title}
                        </h3>
                        <button
                            type="button"
                            class="text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm w-8 h-8 ms-auto inline-flex justify-center items-center dark:hover:bg-gray-600 dark:hover:text-white"
                            data-modal-hide="default-modal"
                            onclick={props.on_close.clone()}
                        >
                            <svg class="w-3 h-3" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14">
                                <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m1 1 6 6m0 0 6 6M7 7l6-6M7 7l-6 6"/>
                            </svg>
                            <span class="sr-only">{"Close modal"}</span>
                        </button>
                    </div>
                    // Modal body
                    <div class="relative p-6 flex-auto">
                        {props.children.clone()}
                    </div>

                    { if !props.hide_actions {
                        html! {
                            // Modal footer
                            <div class="flex items-center justify-end p-6 border-t border-solid rounded-b border-blueGray-200 dark:border-gray-600">
                                <button
                                    class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800"
                                    onclick={props.on_accept.clone()}
                                >
                                    {ok_label}
                                </button>
                                <button
                                    class="py-2.5 px-5 ms-3 text-sm font-medium text-gray-900 focus:outline-none bg-white rounded-lg border border-gray-200 hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-4 focus:ring-gray-100 dark:focus:ring-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-600 dark:hover:text-white dark:hover:bg-gray-700"
                                    onclick={props.on_decline.clone()}
                                >
                                    {cancel_label}
                                </button>
                            </div>
                        }
                    } else {
                        html! {}
                    } }
                </div>
            </div>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/modal.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/card.rs>>
use yew::prelude::*;

#[derive(Properties, PartialEq)]
pub struct CardProps {
    #[prop_or_default]
    pub title: Option<String>,
    #[prop_or_default]
    pub size: Option<u8>,
    #[prop_or_default]
    pub sm: Option<u8>, // 640px
    #[prop_or_default]
    pub md: Option<u8>, // 768px
    #[prop_or_default]
    pub lg: Option<u8>, // 1024px
    #[prop_or_default]
    pub xl: Option<u8>, // 1280px
    #[prop_or_default]
    pub xxl: Option<u8>, // 1536px
    pub children: Children,
}

#[function_component(Card)]
pub fn card(props: &CardProps) -> Html {
    let mut classes = vec![
        "p-4".to_string(),
        "mb-4".to_string(),
        "bg-white".to_string(),
        "border".to_string(),
        "border-gray-200".to_string(),
        "rounded-lg".to_string(),
        "shadow-sm".to_string(),
        "dark:border-gray-700".to_string(),
        "sm:p-6".to_string(),
        "dark:bg-gray-800".to_string(),
        "text-gray-900".to_string(),
        "dark:text-white".to_string(),
    ];
    if let Some(size) = props.size {
        classes.push(format!("col-span-{}", size));
    }
    if let Some(cols) = props.sm {
        classes.push(format!("sm:col-span-{}", cols));
    }
    if let Some(cols) = props.md {
        classes.push(format!("md:col-span-{}", cols));
    }
    if let Some(cols) = props.lg {
        classes.push(format!("lg:col-span-{}", cols));
    }
    if let Some(cols) = props.xl {
        classes.push(format!("xl:col-span-{}", cols));
    }
    if let Some(cols) = props.xxl {
        classes.push(format!("2xl:col-span-{}", cols));
    }

    let classes = classes!(classes);
    html! {
        <div class={classes}>
            { if let Some(title) = &props.title {
                html! {
                    <h3
                        class="flex items-center mb-4 text-xl font-semibold text-gray-900 dark:text-white"
                    >
                        { title }
                    </h3>
                }
            } else {
                html! {}
            } }
            { for props.children.iter() }
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/card.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/components/button.rs>>
use yew::prelude::*;

use super::Icons;

#[allow(unused)]
#[derive(Clone, PartialEq, Debug)]
pub enum ButtonSize {
    ExtraSmall,
    Small,
    Base,
    Large,
    ExtraLarge,
}

impl ButtonSize {
    pub fn icon_size(&self) -> usize {
        match self {
            ButtonSize::ExtraSmall => 12,
            ButtonSize::Small => 12,
            ButtonSize::Base => 14,
            ButtonSize::Large => 16,
            ButtonSize::ExtraLarge => 16,
        }
    }
}

impl ToString for ButtonSize {
    fn to_string(&self) -> String {
        match self {
            ButtonSize::ExtraSmall => "px-3 py-2 text-xs font-medium text-center inline-flex items-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800".to_string(),
            ButtonSize::Small => "px-3 py-2 text-sm font-medium text-center inline-flex items-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800".to_string(),
            ButtonSize::Base => "px-5 py-2.5 text-sm font-medium text-white inline-flex items-center bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 rounded-lg text-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800".to_string(),
            ButtonSize::Large => "px-5 py-3 text-base font-medium text-center inline-flex items-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800".to_string(),
            ButtonSize::ExtraLarge => "px-6 py-3.5 text-base font-medium text-white inline-flex items-center bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 rounded-lg text-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800".to_string(),
        }
    }
}

#[derive(Properties, PartialEq)]
pub struct ButtonProps {
    pub on_click: Callback<MouseEvent>,
    pub text: String,
    #[prop_or(ButtonSize::Base)]
    pub size: ButtonSize,
    #[prop_or_default]
    pub class: Option<String>,
    #[prop_or_default]
    pub icon: Option<Icons>,
}

#[function_component(Button)]
pub fn button(props: &ButtonProps) -> Html {
    let onclick = props.on_click.clone();
    let text = props.text.clone();
    let class = classes!(props.size.to_string(), props.class.clone());
    let margin = if props.icon.is_some() { "ml-1" } else { "" };
    let text_class = classes!(margin);

    html! {
        <button onclick={onclick} class={class}>
            { if let Some(icon) = &props.icon {
                icon.to_svg(props.size.icon_size()).into()
            } else {
                html! {}
            } }
            <div class={text_class}>{ text }</div>
        </button>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/components/button.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/main.rs>>
mod app;
mod components;
mod contexts;
mod http;
mod models;
mod pages;
mod services;
mod utils;

pub use app::App;

fn main() {
    yew::Renderer::<App>::new().render();
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/main.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/http.rs>>
use std::fmt;

use gloo_net::http::{Request, RequestBuilder, Response};
use gloo_storage::{LocalStorage, Storage};
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum Error {
    GlooError(String),
    JsonError(String),
    Unauthorized(String),
    Other(String),
}

impl std::error::Error for Error {}

impl From<gloo_net::Error> for Error {
    fn from(err: gloo_net::Error) -> Self {
        Self::GlooError(err.to_string())
    }
}

impl From<serde_json::Error> for Error {
    fn from(err: serde_json::Error) -> Self {
        Self::JsonError(err.to_string())
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::GlooError(err) => write!(f, "{}", err),
            Self::JsonError(err) => write!(f, "JSON error: {}", err),
            Self::Unauthorized(err) => write!(f, "Unauthorized ({})", err),
            Self::Other(err) => write!(f, "{}", err),
        }
    }
}

pub type Result<T> = std::result::Result<T, Error>;

async fn send(req: RequestBuilder, body: Option<Value>) -> Result<Response> {
    let req = auth_header(req);
    let req = if let Some(body) = body {
        req.json(&body)?
    } else {
        req.build()?
    };
    let res = req.send().await?;
    match res.status() {
        200..=299 => Ok(res),
        401 => Err(Error::Unauthorized(res.text().await?)),
        _ => Err(Error::GlooError(res.text().await?)),
    }
}

pub async fn get(url: &str) -> Result<Response> {
    Ok(send(Request::get(url), None).await?)
}

pub async fn post<T: Serialize + ?Sized>(url: &str, body: &T) -> Result<Response> {
    Ok(send(Request::post(url), Some(serde_json::to_value(body)?)).await?)
}

fn auth_header(req: RequestBuilder) -> RequestBuilder {
    let token = LocalStorage::get::<String>("token");

    if let Ok(token) = token {
        return req.header("Authorization", &format!("Bearer {}", token));
    }
    req
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/http.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/app.rs>>
use gloo_storage::{LocalStorage, Storage};
use paperiq_types::UserWithSettings;
use web_sys::window;
use yew::prelude::*;
use yew_hooks::use_async;
use yew_router::prelude::*;

use crate::contexts::{UserContext, UserProvider};
use crate::http::{self, get};
use crate::pages::{Dashboard, Form, Forms, Login, Logout, Register, Scan, Scans, Welcome};

#[derive(Clone, Routable, PartialEq)]
pub enum Route {
    #[at("/")]
    Home,

    #[at("/register")]
    Register,

    #[at("/login")]
    Login,

    #[at("/logout")]
    Logout,

    #[at("/welcome")]
    Welcome,

    #[at("/dashboard")]
    Dashboard,

    #[at("/forms")]
    Forms,

    #[at("/forms/:id")]
    Form { id: i32 },

    #[at("/scans")]
    Scans,

    #[at("/scans/:id")]
    Scan { id: i32 },

    #[not_found]
    #[at("/404")]
    NotFound,
}

#[derive(Properties, PartialEq)]
pub struct WrapperProps {
    pub children: Children,
}

#[function_component(LoggedOutWrapper)]
fn loged_out_wrapper(props: &WrapperProps) -> Html {
    let navigator = use_navigator().unwrap();

    use_effect(move || {
        if let Some(window) = window() {
            match window.local_storage() {
                Ok(Some(storage)) => {
                    if let Ok(Some(token)) = storage.get_item("token") {
                        if !token.is_empty() {
                            navigator.replace(&Route::Home);
                        }
                    }
                }
                _ => {}
            }
        }
        || ()
    });

    html! {
        <>
            { for props.children.iter() }
        </>
    }
}

#[function_component(LoggedInWrapper)]
fn loged_in_wrapper(props: &WrapperProps) -> Html {
    let navigator = use_navigator().unwrap();
    let user_context = use_context::<UserContext>().expect("No UserContext provided");

    let user = use_async::<_, _, http::Error>(async move { has_user().await });

    {
        let user = user.clone();
        let navigator = navigator.clone();
        use_effect_with((), move |_| {
            let Some(window) = window() else {
                return navigator.replace(&Route::Login);
            };
            let Ok(Some(storage)) = window.local_storage() else {
                return navigator.replace(&Route::Login);
            };
            let Ok(Some(token)) = storage.get_item("token") else {
                return navigator.replace(&Route::Login);
            };
            if token.is_empty() {
                return navigator.replace(&Route::Login);
            } else {
                user.run();
            }
        });
    }

    {
        let user = user.clone();
        let update_user = user_context.update_user.clone();
        let navigator = navigator.clone();
        use_effect_with(user, move |user| {
            if let Some(result) = &user.data {
                match result {
                    Some(user_data) => {
                        update_user.emit(Some(user_data.clone()));
                    }
                    None => {
                        LocalStorage::delete("token");
                        navigator.replace(&Route::Login);
                    }
                }
            }
            || ()
        });
    }

    html! {
        <>
            { for props.children.iter() }
        </>
    }
}

async fn has_user() -> Result<Option<UserWithSettings>, http::Error> {
    match get("/api/user").await {
        Ok(response) => {
            let user: UserWithSettings = response.json().await?;
            Ok(Some(user))
        }
        Err(err) => match err {
            http::Error::Unauthorized(_) => Ok(None),
            _ => Err(err),
        },
    }
}

fn switch(routes: Route) -> Html {
    match routes {
        // Route::Home => html! { <h1>{ "Home" }</h1> },
        Route::Register => html! { <LoggedOutWrapper><Register /></LoggedOutWrapper> },
        Route::Login => html! { <LoggedOutWrapper><Login /></LoggedOutWrapper> },

        Route::Logout => html! { <LoggedInWrapper><Logout /></LoggedInWrapper> },
        Route::Welcome => html! { <LoggedInWrapper><Welcome /></LoggedInWrapper> },
        Route::Dashboard | Route::Home => {
            html! { <LoggedInWrapper><Dashboard /></LoggedInWrapper> }
        }
        Route::Scans => html! { <LoggedInWrapper><Scans /></LoggedInWrapper> },
        Route::Scan { id } => html! { <LoggedInWrapper><Scan id={id} /></LoggedInWrapper> },
        Route::Forms => html! { <LoggedInWrapper><Forms /></LoggedInWrapper> },
        Route::Form { id } => html! { <LoggedInWrapper><Form id={id} /></LoggedInWrapper> },

        Route::NotFound => html! { <h1>{ "404" }</h1> },
    }
}

#[function_component(App)]
pub fn app() -> Html {
    html! {
        <UserProvider>
            <BrowserRouter>
                <Switch<Route> render={switch} />
            </BrowserRouter>
        </UserProvider>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/app.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/register.rs>>
use gloo_net::http::Request;
use gloo_storage::{LocalStorage, Storage};
use serde::{Deserialize, Serialize};
use wasm_bindgen_futures::spawn_local;
use web_sys::HtmlInputElement;
use yew::prelude::*;
use yew_router::hooks::use_navigator;

use crate::app::Route;

#[derive(Serialize, Deserialize)]
struct LoginResponse {
    token: String,
}

#[function_component(Register)]
pub fn register() -> Html {
    let email = use_state(String::new);
    let password = use_state(String::new);
    let error = use_state(|| None::<String>);
    let navigator = use_navigator().unwrap();

    let onsubmit = {
        let email = email.clone();
        let password = password.clone();
        let error = error.clone();
        let navigator = navigator.clone();

        Callback::from(move |e: SubmitEvent| {
            e.prevent_default();

            let email = email.clone();
            let password = password.clone();
            let error = error.clone();
            let navigator = navigator.clone();

            spawn_local(async move {
                let resp = Request::post("/api/register")
                    .json(&serde_json::json!({
                        "email": &*email,
                        "password": &*password,
                    }))
                    .unwrap()
                    .send()
                    .await;

                match resp {
                    Ok(resp) => {
                        if resp.status() == 200 {
                            let login_resp: LoginResponse = resp.json().await.unwrap();
                            LocalStorage::set("token", &login_resp.token).unwrap();
                            error.set(None);
                            return navigator.push(&Route::Dashboard);
                        } else {
                            // TODO: handle error
                            let error_message = resp.text().await.unwrap();
                            error.set(format!("{error_message}").into());
                        }
                    }
                    Err(_) => {
                        error.set(Some("Network error".to_string()));
                    }
                }
            });
        })
    };

    let oninput_email = {
        let email = email.clone();
        Callback::from(move |e: InputEvent| {
            let input: HtmlInputElement = e.target_unchecked_into();
            email.set(input.value());
        })
    };

    let oninput_password = {
        let password = password.clone();
        Callback::from(move |e: InputEvent| {
            let input: HtmlInputElement = e.target_unchecked_into();
            password.set(input.value());
        })
    };

    html! {
        <div class="flex flex-col items-center justify-center px-6 pt-8 mx-auto h-screen dark:bg-gray-900">
            <a href="/"
               class="flex items-center justify-center mb-8 text-2xl font-semibold lg:mb-10 dark:text-white"
            >
                <img src="img/logo.png" class="mr-4 h-11" alt="PaperIQ Logo" />
                <span>{"PaperIQ"}</span>
            </a>

            <div class="w-full max-w-xl p-6 space-y-8 sm:p-8 bg-white rounded-lg shadow dark:bg-gray-800">
                <h2 class="text-2xl font-bold text-gray-900 dark:text-white">
                    {"Create a Free Account"}
                </h2>

                if let Some(error_message) = (*error).clone() {
                    <div class="p-4 mb-4 text-sm text-red-800 rounded-lg bg-red-50 dark:bg-gray-700 dark:text-red-400" role="alert">
                        <span class="font-medium">{"Error!"}</span> {" "}{error_message}
                    </div>
                }

                <form class="mt-8 space-y-6" action="#" onsubmit={onsubmit}>
                    <div>
                        <label for="email" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">{"Your email"}</label>
                        <input type="email" name="email" id="email" class="bg-gray-50 border border-gray-300 text-gray-900 sm:text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-primary-500 dark:focus:border-primary-500" required=true oninput={oninput_email} />
                    </div>

                    <div>
                        <label for="password" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">{"Your password"}</label>
                        <input type="password" name="password" id="password" class="bg-gray-50 border border-gray-300 text-gray-900 sm:text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-primary-500 dark:focus:border-primary-500" required=true oninput={oninput_password} />
                    </div>
                    <div class="flex items-start">
                        <div class="flex items-center h-5">
                            <input id="remember" aria-describedby="remember" name="remember" type="checkbox" class="w-4 h-4 border-gray-300 rounded bg-gray-50 focus:ring-3 focus:ring-primary-300 dark:focus:ring-primary-600 dark:ring-offset-gray-800 dark:bg-gray-700 dark:border-gray-600" required=true />
                        </div>
                        <div class="ml-3 text-sm">
                            <label for="remember" class="font-medium text-gray-900 dark:text-white">{"I accept the "}<a href="#" class="text-primary-700 hover:underline dark:text-primary-500">{"Terms and Conditions"}</a></label>
                        </div>
                    </div>
                    <button type="submit" class="w-full px-5 py-3 text-base font-medium text-center text-white bg-primary-700 rounded-lg hover:bg-primary-800 focus:ring-4 focus:ring-primary-300 sm:w-auto bg-primary-600 hover:bg-primary-700 focus:ring-primary-800">{"Create account"}</button>
                    <div class="text-sm font-medium text-gray-500 dark:text-gray-400">
                        {"Already have an account? "}
                        <a href="/login" class="text-primary-700 hover:underline dark:text-primary-500">{"Login here"}</a>
                    </div>
                </form>
            </div>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/register.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/logout.rs>>
use gloo_storage::{LocalStorage, Storage};
use yew::prelude::*;
use yew_router::hooks::use_navigator;

use crate::app::Route;

#[function_component(Logout)]
pub fn logout() -> Html {
    let navigator = use_navigator().unwrap();

    LocalStorage::delete("token");
    navigator.replace(&Route::Login);

    html! {
        <div class="flex items-center justify-center h-screen">
            <div class="text-center">
                <h1 class="text-4xl font-bold">{"Logging out..."}</h1>
            </div>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/logout.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/dashboard/transactions.rs>>
use serde::{Deserialize, Serialize};
use serde_json::Value;
use web_sys::console;
use yew::prelude::*;
use yew_hooks::prelude::*;
use yew_router::hooks::use_navigator;

use crate::{
    app::Route,
    components::{Loader, RowType, Table},
    http::{self, get, Result},
    utils::get_status_class,
};

#[derive(Serialize, Deserialize, Clone, Debug)]
struct Request {
    id: i32,
    status: String,
    percentage: i32,
    error: Option<String>,
    #[serde(rename = "type")]
    typ: String,
    images: Vec<String>,
    response: Option<Value>,
    data: Option<Value>,
    created_at: chrono::NaiveDateTime,
    modified_at: chrono::NaiveDateTime,
}

#[function_component(Transactions)]
pub fn transactions() -> Html {
    let navigator = use_navigator().unwrap();
    let rows = use_async::<_, _, http::Error>(async move {
        let result = get_request_rows().await;
        match result {
            Ok(data) => Ok(data),
            Err(err) => {
                let msg = format!("error: {}", err);
                console::log_1(&msg.into());
                Err(err)
            }
        }
    });

    let headers = vec![
        "ID".to_string(),
        "Type".to_string(),
        "Last updated".to_string(),
        "Progress".to_string(),
        "Status".to_string(),
        "".to_string(),
    ];

    {
        let rows = rows.clone();
        use_effect_with((), move |_| {
            rows.run();
            || ()
        });
    }

    if let Some(data) = &rows.data {
        if data.is_empty() {
            html! { "No requests found" }
        } else {
            let data = data.clone();
            let rows = table_rows(&data);

            html! {
                <Table
                    headers={headers}
                    rows={rows}
                    onrowclick={move |i| {
                        let row: &Request = &data[i];
                        if row.typ == "scan" {
                            navigator.push(&Route::Scan { id: row.id });
                        } else if row.typ == "form" {
                            navigator.push(&Route::Form { id: row.id });
                        }
                    }}
                />
            }
        }
    } else if let Some(err) = &rows.error {
        html! { err }
    } else {
        html! { <Loader /> }
    }
}

async fn get_request_rows() -> Result<Vec<Request>> {
    let resp = get("/api/requests?sort=created_at&order=DESC&limit=5").await?;
    let reqs: Vec<Request> = resp.json().await?;
    Ok(reqs)
}

fn table_rows(reqs: &Vec<Request>) -> Vec<Vec<RowType>> {
    reqs
        .into_iter()
        .map(|r| {
            let typ = match r.typ.as_str() {
                "scan" => "Scan",
                "form" => "Template",
                _ => "Unknown",
            };
            vec![
                r.id.to_string().into(),
                typ.to_string().into(),
                r.modified_at.into(),
                html! {
                    <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                        <div class="bg-blue-600 h-2.5 rounded-full" style={format!("width: {}%", r.percentage)}></div>
                    </div>
                }.into(),
                html! {
                    <span class={format!("px-2 py-1 text-xs font-medium rounded-full {}", get_status_class(&r.status))}>
                        { r.status.clone() }
                    </span>
                }.into(),
                html! {
                    <img
                        src={format!("data:image/jpg;base64,{}", r.images[0])}
                        class="w-auto h-16 rounded-sm object-cover"
                        alt="Preview"
                    />
                }
                .into(),
            ]
        })
        .collect()
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/dashboard/transactions.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/mod.rs>>
use thiserror::Error;

use crate::http;

mod dashboard;
mod form;
mod forms;
mod login;
mod logout;
mod register;
mod scan;
mod scans;
mod welcome;

pub use dashboard::Dashboard;
pub use welcome::Welcome;
pub use form::Form;
pub use forms::Forms;
pub use login::Login;
pub use logout::Logout;
pub use register::Register;
pub use scan::Scan;
pub use scans::Scans;

#[derive(Debug, Error)]
pub enum Error {
    #[error("HTTP error: {0}")]
    Http(#[from] http::Error),

    #[error("HTTP error: {0}")]
    Url(#[from] gloo_net::Error),

    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),
}

pub type Result<T> = std::result::Result<T, Error>;

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/mod.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/welcome.rs>>
use serde_json::Value;
use yew::prelude::*;
use yew_router::hooks::use_navigator;

use crate::{
    app::Route,
    components::{Breadcrumb, Card, FileUploader, Grid, Layout},
    http::post,
};

#[function_component(Welcome)]
pub fn welcome() -> Html {
    let navigator = use_navigator().unwrap();
    let scan_id = use_state(|| None::<i32>);
    let form_id = use_state(|| None::<i32>);

    {
        let form_id = form_id.clone();
        let navigator = navigator.clone();
        use_effect_with(form_id, move |form_id| {
            if let Some(id) = **form_id {
                wasm_bindgen_futures::spawn_local(async move {
                    let _ = post("/api/settings/welcome", &Value::Bool(true)).await;
                    navigator.replace(&Route::Form { id });
                });
            }
            || {}
        });
    }

    {
        let scan_id = scan_id.clone();
        let navigator = navigator.clone();
        use_effect_with(scan_id, move |scan_id| {
            if let Some(id) = **scan_id {
                wasm_bindgen_futures::spawn_local(async move {
                    let _ = post("/api/settings/welcome", &Value::Bool(true)).await;
                    navigator.replace(&Route::Scan { id });
                });
            }
            || {}
        });
    }

    let items = vec![
        ("Home".to_string(), Some("/".to_string())),
        ("Welcome".to_string(), None),
    ];

    html! {
        <Layout>
            <Breadcrumb items={items} />
            <div class="px-4 pt-6">
                <Card>
                    <div class="text-3xl font-semibold mb-6">
                        {"Welcome to PaperIQ"}
                    </div>
                    <p class="text-lg text-gray-400 my-10">
                        {"To get started, choose one of the options below. You can either upload a blank form template for multiple scans or a completed form for a quick test."}
                    </p>
                    <Grid xxl={2} class="my-10 gap-8">

                        <div class="dark:bg-slate-700 rounded-lg p-10 shadow-md">
                            <div class="flex items-center mb-4">
                                <i class="fas fa-file-alt text-3xl text-blue-500 mr-4"></i>
                                <h3 class="text-xl font-semibold">{"Upload a Blank Form Template"}</h3>
                            </div>

                            <p class="text-gray-400 text-lg my-8">
                                {"Perfect for processing multiple instances of the same form. Improves accuracy and allows customization of expected fields."}
                            </p>

                            <FileUploader
                                onupload={Callback::from(move |id| form_id.set(Some(id)))}
                                url="/api/scan"
                                prompt="form"
                                message={"Click Here to Upload Template"}
                                subtitle="or drag and drop the file here"
                                allowed_types={vec!["image/jpeg".to_string()]}
                            />

                        </div>

                        <div class="dark:bg-slate-700 rounded-lg p-10 shadow-md">
                            <div class="flex items-center mb-4">
                                <i class="fas fa-file-signature text-3xl text-blue-500 mr-4"></i>
                                <h3 class="text-xl font-semibold">{"Upload a Completed Form"}</h3>
                            </div>
                            <p class="text-gray-400 text-lg my-8">
                                {"Quick option for testing our recognition engine on a single, filled-out form. Great for ad-hoc scanning."}
                            </p>

                            <FileUploader
                                onupload={Callback::from(move |id| scan_id.set(Some(id)))}
                                url="/api/scan"
                                prompt="scan"
                                message={"Click Here to Upload Filled Form"}
                                subtitle="or drag and drop the file here"
                                allowed_types={vec!["image/jpeg".to_string()]}
                            />

                        </div>
                    </Grid>
                </Card>
            </div>
        </Layout>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/welcome.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/login.rs>>
use gloo_net::http::Request;
use gloo_storage::{LocalStorage, Storage};
use serde::{Deserialize, Serialize};
use wasm_bindgen_futures::spawn_local;
use web_sys::HtmlInputElement;
use yew::prelude::*;
use yew_router::hooks::use_navigator;

use crate::app::Route;

#[derive(Serialize, Deserialize)]
struct LoginResponse {
    token: String,
}

#[function_component(Login)]
pub fn login() -> Html {
    let email = use_state(String::new);
    let password = use_state(String::new);
    let error = use_state(|| None::<String>);
    let navigator = use_navigator().unwrap();

    let onsubmit = {
        let email = email.clone();
        let password = password.clone();
        let error = error.clone();
        let navigator = navigator.clone();

        Callback::from(move |e: SubmitEvent| {
            e.prevent_default();

            let email = email.clone();
            let password = password.clone();
            let error = error.clone();
            let navigator = navigator.clone();

            spawn_local(async move {
                let resp = Request::post("/api/login")
                    .json(&serde_json::json!({
                        "email": &*email,
                        "password": &*password,
                    }))
                    .unwrap()
                    .send()
                    .await;

                match resp {
                    Ok(resp) => {
                        if resp.status() == 200 {
                            let login_resp: LoginResponse = resp.json().await.unwrap();
                            LocalStorage::set("token", &login_resp.token).unwrap();
                            error.set(None);
                            return navigator.push(&Route::Dashboard);
                        } else {
                            error.set(Some("Invalid credentials".to_string()));
                        }
                    }
                    Err(_) => {
                        error.set(Some("Network error".to_string()));
                    }
                }
            });
        })
    };

    let oninput_email = {
        let email = email.clone();
        Callback::from(move |e: InputEvent| {
            let input: HtmlInputElement = e.target_unchecked_into();
            email.set(input.value());
        })
    };

    let oninput_password = {
        let password = password.clone();
        Callback::from(move |e: InputEvent| {
            let input: HtmlInputElement = e.target_unchecked_into();
            password.set(input.value());
        })
    };

    html! {
        <div class="flex flex-col items-center justify-center px-6 pt-8 mx-auto h-screen dark:bg-gray-900">
            <a href="/"
               class="flex items-center justify-center mb-8 text-2xl font-semibold lg:mb-10 dark:text-white"
            >
                <img src="img/logo.png" class="mr-4 h-11" alt="PaperIQ Logo" />
                <span>{"PaperIQ"}</span>
            </a>

            <div class="w-full max-w-xl p-6 space-y-8 sm:p-8 bg-white rounded-lg shadow dark:bg-gray-800">
                <h2 class="text-2xl font-bold text-gray-900 dark:text-white">
                    {"Sign in to platform"}
                </h2>

                if let Some(error_message) = (*error).clone() {
                    <div class="p-4 mb-4 text-sm text-red-800 rounded-lg bg-red-50 dark:bg-gray-700 dark:text-red-400" role="alert">
                        <span class="font-medium">{"Error!"}</span> {" "}{error_message}
                    </div>
                }

                <form class="mt-8 space-y-6" action="#" onsubmit={onsubmit}>
                    <div>
                        <label for="email" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">{"Your email"}</label>
                        <input type="email" name="email" id="email" class="bg-gray-50 border border-gray-300 text-gray-900 sm:text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-primary-500 dark:focus:border-primary-500" placeholder="name@company.com" required=true oninput={oninput_email} />
                    </div>

                    <div>
                        <label for="password" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">{"Your password"}</label>
                        <input type="password" name="password" id="password" placeholder="••••••••" class="bg-gray-50 border border-gray-300 text-gray-900 sm:text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-primary-500 dark:focus:border-primary-500" required=true oninput={oninput_password} />
                    </div>
                    <div class="flex items-start">
                        <div class="flex items-center h-5">
                            <input id="remember" aria-describedby="remember" name="remember" type="checkbox" class="w-4 h-4 border-gray-300 rounded bg-gray-50 focus:ring-3 focus:ring-primary-300 dark:focus:ring-primary-600 dark:ring-offset-gray-800 dark:bg-gray-700 dark:border-gray-600" />
                        </div>
                        <div class="ml-3 text-sm">
                            <label for="remember" class="font-medium text-gray-900 dark:text-white">{"Remember me"}</label>
                        </div>
                        <a href="#" class="ml-auto text-sm text-primary-700 hover:underline dark:text-primary-500">{"Lost Password?"}</a>
                    </div>
                    <button type="submit" class="w-full px-5 py-3 text-base font-medium text-center text-white bg-primary-700 rounded-lg hover:bg-primary-800 focus:ring-4 focus:ring-primary-300 sm:w-auto bg-primary-600 hover:bg-primary-700 focus:ring-primary-800">{"Login to your account"}</button>
                    <div class="text-sm font-medium text-gray-500 dark:text-gray-400">
                        {"Not registered? "}
                        <a href="/register" class="text-primary-700 hover:underline dark:text-primary-500">{"Create account"}</a>
                    </div>
                </form>
            </div>
        </div>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/login.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/scans.rs>>
use std::collections::HashMap;

use serde_json::Value;
use yew::prelude::*;
use yew_router::hooks::use_navigator;

use crate::{
    app::Route,
    components::{
        Breadcrumb, Button, ButtonSize, Card, FileUploader, Layout, Loader, Modal, RenderType,
        ScansTable, Select,
    },
    services::get_form_pairs,
};

#[function_component(Scans)]
pub fn scans() -> Html {
    let is_modal_open = use_state(|| false);

    let items = vec![
        ("Home".to_string(), Some("/".to_string())),
        ("Dashboard".to_string(), Some("/dashboard".to_string())),
        (format!("Scans"), None),
    ];

    let is_modal_open_clone = is_modal_open.clone();
    let onclick = Callback::from(move |_| is_modal_open_clone.set(true));

    let is_modal_open_clone = is_modal_open.clone();
    let onclose = Callback::from(move |_| is_modal_open_clone.set(false));

    html! {
        <Layout>
            <Breadcrumb items={items} />
            <div class="px-4 pt-6">
                <Card title="Scans" xxl=3>
                    <ScansTable kind="scan" />

                    <Button
                        text="New Scan"
                        size={ButtonSize::Large}
                        on_click={onclick}
                        class="mt-4"
                    />

                    <Modal
                        title="New Scan"
                        is_open={*is_modal_open}
                        hide_actions=true
                        on_close={onclose}
                    >
                        <p>{""}</p>
                        <FormSelect />
                    </Modal>
                </Card>
            </div>
        </Layout>
    }
}

#[function_component(FormSelect)]
pub fn form_select() -> Html {
    let navigator = use_navigator().unwrap();
    let loading = use_state(|| true);
    let forms = use_state(|| vec![]);
    let error = use_state(|| None::<String>);
    let selected_form = use_state(|| None::<String>);

    {
        let forms = forms.clone();
        let error = error.clone();
        let loading = loading.clone();
        use_effect_with((), move |_| {
            wasm_bindgen_futures::spawn_local(async move {
                let res = get_form_pairs().await;
                match res {
                    Ok(response) => {
                        error.set(None);
                        forms.set(response);
                        loading.set(false);
                    }
                    Err(err) => {
                        error.set(Some(err.to_string()));
                        forms.set(vec![]);
                        loading.set(false);
                    }
                }
            });

            || ()
        });
    }

    let on_select = {
        let selected_form = selected_form.clone();
        Callback::from(move |id: String| {
            web_sys::console::log_1(&format!("Selected form: {}", id).into());
            selected_form.set(Some(id));
        })
    };

    if *loading {
        html! { <Loader /> }
    } else if let Some(err) = error.as_ref() {
        html! { <p>{err}</p> }
    } else {
        let selected_form = selected_form.clone();
        let form_id = selected_form.as_ref().cloned();
        web_sys::console::log_1(&form_id.clone().unwrap_or("None".to_string()).into());
        let mut attrs = HashMap::new();
        if let Some(form_id) = form_id.clone() {
            let form_id = form_id.parse::<u32>().unwrap();
            attrs.insert("form_id".to_string(), Value::Number(form_id.into()));
        }

        let on_upload = { Callback::from(move |id| navigator.push(&Route::Scan { id })) };
        html! {
            <>
                <Select
                    label="Chose the form you want to use as a template for the new scan"
                    options={(*forms).clone()}
                    on_change={on_select}
                />
                <FileUploader
                    url="/api/scan"
                    onupload={on_upload}
                    prompt="scan"
                    render_type={RenderType::Button}
                    button_text="Select File"
                    button_size={ButtonSize::Small}
                    attributes={attrs}
                    class="mt-4"
                />
            </>
        }
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/scans.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/scan.rs>>
use std::future::Future;
use std::pin::Pin;

use yew::prelude::*;

use crate::components::{Breadcrumb, Card, Layout, RequestLoader, Viewer};
use crate::{http::get, models::ScanRequest};

#[derive(Properties, Clone, PartialEq)]
pub struct ScanProps {
    pub id: i32,
}

#[function_component(Scan)]
pub fn scan(props: &ScanProps) -> Html {
    let id = props.id;

    let items = vec![
        ("Home".to_string(), Some("/".to_string())),
        ("Dashboard".to_string(), Some("/dashboard".to_string())),
        (format!("Scan {}", props.id), None),
    ];

    let render = Callback::from(move |scan: ScanRequest| {
        html! {
            <div class="grid grid-cols-1 md:grid-cols-2 h-[calc(100vh-200px)]">
                <div class="overflow-y-auto pr-4">
                    { scan.fields().into_iter().enumerate().map(|(i, field)| {
                        html! {
                            <div class="mb-5">
                                <label
                                    for={format!("field-{i}")}
                                    class="block mb-2 text-sm font-medium text-gray-900 dark:text-white"
                                >
                                    {field.name.clone()}
                                </label>
                                <input
                                    id={format!("field-{i}")}
                                    name={field.name.clone()}
                                    class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
                                    value={field.value}
                                />
                            </div>
                        }
                    }).collect::<Html>() }
                </div>
                <Viewer image={scan.images[0].clone()} fields={scan.fields()}/>
                </div>
        }
    });

    let request = Callback::from(
        move |_| -> Pin<Box<dyn Future<Output = anyhow::Result<ScanRequest>>>> {
            let id = id;
            Box::pin(async move { get_scan(id).await })
        },
    );

    html! {
        <Layout>
            <Breadcrumb items={items} />
            <div class="px-4 pt-6">
                <Card title={format!("Scan {}", id)} xxl=5>
                    <RequestLoader request={request} render={render} />
                </Card>
            </div>
        </Layout>
    }
}

async fn get_scan(id: i32) -> anyhow::Result<ScanRequest> {
    let response = get(&format!("/api/requests/{}", id)).await?;
    Ok(response.json().await?)
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/scan.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/dashboard.rs>>
mod transactions;

use std::collections::HashMap;

use web_sys::{console, HtmlSelectElement};
use yew::prelude::*;
use yew_router::hooks::use_navigator;

use crate::app::Route;
use crate::components::{Breadcrumb, Card, FileUploader, Grid, Layout};
use crate::contexts::UserContext;
use crate::http::get;
use crate::models::FormData;

#[function_component(Dashboard)]
pub fn dashboard() -> Html {
    let request_id = use_state(|| None::<i32>);
    let forms = use_state(|| vec![]);
    let selected_form = use_state(|| None::<i32>);
    let navigator = use_navigator().unwrap();
    let user_ctx = use_context::<UserContext>().expect("No user context found");
    let user_state = &*user_ctx.state;

    {
        let user_state = user_state.clone();
        use_effect_with(user_state, move |user_state| {
            if !user_state.is_loading {
                if let Some(user) = user_state.user.as_ref() {
                    if user.settings.get("welcome").is_none() {
                        navigator.replace(&Route::Welcome);
                    }
                }
            }
            || {}
        });
    }

    let items = vec![
        ("Home".to_string(), Some("/".to_string())),
        ("Dashboard".to_string(), None),
    ];

    let onupload = {
        let request_id = request_id.clone();
        Callback::from(move |id: i32| {
            request_id.set(Some(id));
        })
    };

    {
        let forms = forms.clone();
        use_effect_with((), move |_| {
            let forms = forms.clone();
            wasm_bindgen_futures::spawn_local(async move {
                match get("/api/requests?type=form&omit_images=true").await {
                    Ok(response) => {
                        let fetched_forms: Vec<FormData> = response.json().await.unwrap();
                        forms.set(fetched_forms);
                    }
                    Err(err) => {
                        console::error_1(&format!("Failed to fetch forms: {}", err).into());
                    }
                }
            });
            || ()
        });
    }

    let on_form_change = {
        let selected_form = selected_form.clone();
        Callback::from(move |e: Event| {
            let input: HtmlSelectElement = e.target_unchecked_into();
            let value = input.value().parse::<i32>().ok();
            selected_form.set(value);
        })
    };

    let mut attributes = HashMap::new();
    attributes.insert(
        "form_id".to_string(),
        selected_form.map(|id| id).unwrap_or_default().into(),
    );

    html! {
        <Layout>
            <Breadcrumb items={items} />
            <div class="px-4 pt-6">
                <Grid xxl=5>
                    <Card title="Recent Activity" xxl=3>
                        <transactions::Transactions />
                    </Card>
                    <Card xxl=2>
                        if let Some(request_id) = *request_id {
                            <div>{"id is "}{request_id}</div>
                        } else {
                            <>
                                <div class="mb-4">
                                    <label
                                        for="form-select"
                                        class="block mb-2 text-sm font-medium text-gray-900 dark:text-white"
                                    >
                                        {"Select Form (optional)"}
                                    </label>
                                    <select
                                        id="form-select"
                                        class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
                                        onchange={on_form_change}
                                    >
                                        <option selected=true>{ "-- No form --" }</option>
                                        { for forms.iter().filter(|form| form.data.is_some()).map(|form| {
                                            let name = form.data.as_ref().unwrap()["name"].as_str().unwrap();
                                            html! {
                                                <option value={form.id.to_string()}>{ name }</option>
                                            }
                                        }) }
                                    </select>
                                </div>
                                <FileUploader
                                    onupload={onupload}
                                    url="/api/scan"
                                    prompt="scan"
                                    message="Scan new document"
                                    attributes={attributes}
                                    allowed_types={vec!["image/jpeg".to_string()]}
                                />
                            </>
                        }
                    </Card>
                </Grid>
            </div>
        </Layout>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/dashboard.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/forms.rs>>
use yew::prelude::*;

use crate::components::{
    Breadcrumb, ButtonSize, Card, FileUploader, Layout, RenderType, ScansTable,
};

#[function_component(Forms)]
pub fn forms() -> Html {
    let items = vec![
        ("Home".to_string(), Some("/".to_string())),
        ("Dashboard".to_string(), Some("/dashboard".to_string())),
        (format!("Forms"), None),
    ];

    html! {
        <Layout>
            <Breadcrumb items={items} />
            <div class="px-4 pt-6">
                <Card title="Forms" xxl=3>
                    <ScansTable kind="form" />
                    <FileUploader
                        url="/api/scan"
                        prompt="form"
                        render_type={RenderType::Button}
                        button_text="New Form"
                        button_size={ButtonSize::Large}
                        class="mt-4"
                    />
                </Card>
            </div>
        </Layout>
    }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/forms.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/pages/form.rs>>
use std::collections::HashMap;
use std::future::Future;
use std::pin::Pin;

use paperiq_types::{FormData, FormSection};
use serde_json::Value;
use yew::prelude::*;
use yew_hooks::use_async;
use yew_router::hooks::use_navigator;

use super::Result;
use crate::app::Route;
use crate::components::{
    Breadcrumb, ButtonSize, Card, FileUploader, Layout, Loader, RenderType, RequestLoader, Tab,
    Table, Tabs,
};
use crate::utils::transform_to_table;
use crate::{http::get, models::ScanRequest};

#[derive(Properties, Clone, PartialEq)]
pub struct FormProps {
    pub id: i32,
    #[prop_or_default]
    pub path: Option<String>,
}

#[function_component(Form)]
pub fn form(props: &FormProps) -> Html {
    let props = props.clone();
    let navigator = use_navigator().unwrap();

    let items = vec![
        ("Home".to_string(), Some("/".to_string())),
        ("Dashboard".to_string(), Some("/dashboard".to_string())),
    ];

    let navigator = navigator.clone();
    let render = Callback::from(move |scan: ScanRequest| {
        let navigator = navigator.clone();
        let data: Option<FormData> = match scan.data {
            Some(data) => Some(serde_json::from_value(data.clone()).unwrap()),
            None => None,
        };
        // TODO: how to handle this case?
        // items.push((format!("{}", data.name), None));

        let attrs: HashMap<String, Value> =
            HashMap::from_iter(vec![("form_id".to_string(), scan.id.into())]);

        html! {
            <Tabs>
                <Tab label="Fields">
                    { if let Some(data) = data {
                        html! {
                                <Fields sections={data.sections} image={scan.images[0].clone()} />
                        }
                    } else {
                        html! {}
                    } }
                </Tab>
                <Tab label="Data" name="data">
                    <Data id={props.id}  />
                    <FileUploader
                        url="/api/scan"
                        onupload={Callback::from(move |_| navigator.push(&Route::Form { id: props.id }))}
                        prompt="scan"
                        render_type={RenderType::Button}
                        button_text="New Scan"
                        button_size={ButtonSize::Large}
                        attributes={attrs}
                    />
                </Tab>
            </Tabs>
        }
    });

    let id = props.id;
    let request = Callback::from(
        move |_| -> Pin<Box<dyn Future<Output = anyhow::Result<ScanRequest>>>> {
            let id = id;
            Box::pin(async move { get_form(id).await })
        },
    );

    html! {
        <Layout>
            <Breadcrumb items={items} />
            <div class="px-4 pt-6">
                <RequestLoader request={request} render={render} />
            </div>
        </Layout>
    }
}

#[derive(Properties, Clone, PartialEq)]
pub struct FieldsProps {
    pub sections: Vec<FormSection>,
    pub image: String,
}

#[function_component(Fields)]
fn form_fields(props: &FieldsProps) -> Html {
    html! {
        <div class="px-2 pt-6">
            <div class="grid grid-cols-1 md:grid-cols-2 h-[calc(100vh-200px)]">
                <div class="col-span-1 overflow-y-auto">
                    {props.sections.iter().map(|section| {
                        let headers = vec![
                            "Label".to_string(),
                            "Name".to_string(),
                            "Type".to_string(),
                            "Options".to_string(),
                        ];

                        let rows = section.fields.iter().map(|field| {
                            vec![
                                field.label.to_string().into(),
                                field.name.to_string().into(),
                                field.typ.to_string().into(),
                                field.options.clone().unwrap_or_default().join(", ").into(),
                            ]
                        }).collect::<Vec<_>>();

                        html! {
                            <Card title={section.section.clone()} size=1 md=2>
                                <Table headers={headers} rows={rows} />
                            </Card>
                        }
                    }).collect::<Html>()}
                </div>
                <div class="p-4 overflow-y-auto col-span-1">
                    <img src={format!("data:image/jpg;base64,{}", props.image)} alt="form" />
                </div>
            </div>
        </div>
    }
}

#[derive(Properties, Clone, PartialEq)]
pub struct DataProps {
    pub id: i32,
}

#[function_component(Data)]
fn form_data(props: &DataProps) -> Html {
    let props = props.clone();
    let navigator = use_navigator().unwrap();
    let form_data =
        use_async(async move { get_form_data(props.id).await.map_err(|e| e.to_string()) });

    {
        let form_data = form_data.clone();
        use_effect_with(props.id, move |_| {
            form_data.run();
            || ()
        });
    }

    if let Some(form_data) = &form_data.data {
        let onrowclick = {
            let form_data = form_data.clone();
            Callback::from(move |i| {
                web_sys::console::log_1(&format!("Row clicked: {:?}", form_data[i]).into());
                let row: &serde_json::Value = &form_data[i];
                let id: i32 = row["_id"].as_i64().unwrap() as i32;
                navigator.push(&Route::Scan { id });
            })
        };

        let data = transform_to_table(form_data);
        if data.is_empty() {
            html! {
                <div class="px-2 pt-6">
                    <Card>
                        <div class="text-center text-gray-400">{"No data"}</div>
                    </Card>
                </div>
            }
        } else {
            html! {
                <div class="px-2 pt-6">
                    <Card>
                        <Table
                            headers={data.headers}
                            rows={data.rows}
                            csv_download=true
                            onrowclick={onrowclick}
                        />
                    </Card>
                </div>
            }
        }
    } else if let Some(err) = &form_data.error {
        html! { <p>{err}</p> }
    } else {
        html! { <Loader /> }
    }
}

async fn get_form(id: i32) -> anyhow::Result<ScanRequest> {
    let response = get(&format!("/api/requests/{}", id)).await?;
    Ok(response.json().await?)
}

async fn get_form_data(id: i32) -> Result<Vec<Value>> {
    let response = get(&format!("/api/forms/{}/data", id)).await?;
    Ok(response.json().await?)
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/pages/form.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/services/mod.rs>>
mod form;

pub use form::get_form_pairs;

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/services/mod.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/services/form.rs>>
use crate::{
    http::{get, Result},
    models::Form,
};

pub async fn get_form_pairs() -> Result<Vec<(String, String)>> {
    let response = get("/api/requests?x=y&type=form&omit_images=true").await?;
    let forms: Vec<Form> = response.json().await?;
    Ok(forms
        .into_iter()
        .map(|form| {
            (
                form.id.to_string(),
                form.name().unwrap_or(format!("Form #{}", form.id)),
            )
        })
        .collect())
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/services/form.rs>>
<<<START_FILE:/Users/fcoury/code/paperiq/client/src/utils.rs>>
use serde_json::Value;

use crate::components::RowType;

pub fn get_status_class(status: &str) -> &'static str {
    match status.to_lowercase().as_str() {
        "completed" => "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300",
        "processing" => "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300",
        "error" => "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300",
        _ => "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300",
    }
}

#[derive(Debug)]
pub struct Table {
    pub headers: Vec<String>,
    pub rows: Vec<Vec<RowType>>,
}

impl Table {
    pub fn is_empty(&self) -> bool {
        self.rows.is_empty()
    }
}

pub fn transform_to_table(data: &Vec<Value>) -> Table {
    let data = data
        .iter()
        .filter(|d| d.is_object())
        .cloned()
        .collect::<Vec<Value>>();
    let headers = if let Some(first_map) = data.first() {
        first_map.as_object().unwrap().keys().cloned().collect()
    } else {
        Vec::new()
    };

    let rows = data
        .into_iter()
        .map(|map| {
            headers
                .iter()
                .filter(|_| map.is_object())
                .map(|key| {
                    map.as_object()
                        .unwrap()
                        .get(key)
                        .cloned()
                        .unwrap_or(Value::Null)
                        .into()
                })
                .collect()
        })
        .collect();

    Table { headers, rows }
}

<<<END_FILE:/Users/fcoury/code/paperiq/client/src/utils.rs>>
